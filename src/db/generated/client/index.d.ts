
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model FeaturedMediaVideo
 * 
 */
export type FeaturedMediaVideo = $Result.DefaultSelection<Prisma.$FeaturedMediaVideoPayload>
/**
 * Model FeaturedMediaExternalVideo
 * 
 */
export type FeaturedMediaExternalVideo = $Result.DefaultSelection<Prisma.$FeaturedMediaExternalVideoPayload>
/**
 * Model FeaturedMediaImage
 * 
 */
export type FeaturedMediaImage = $Result.DefaultSelection<Prisma.$FeaturedMediaImagePayload>
/**
 * Model ProductFeaturedMedia
 * 
 */
export type ProductFeaturedMedia = $Result.DefaultSelection<Prisma.$ProductFeaturedMediaPayload>
/**
 * Model ProductSEO
 * 
 */
export type ProductSEO = $Result.DefaultSelection<Prisma.$ProductSEOPayload>
/**
 * Model ProductVariantProduct
 * 
 */
export type ProductVariantProduct = $Result.DefaultSelection<Prisma.$ProductVariantProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model OrderPrice
 * 
 */
export type OrderPrice = $Result.DefaultSelection<Prisma.$OrderPricePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model CollectionImage
 * 
 */
export type CollectionImage = $Result.DefaultSelection<Prisma.$CollectionImagePayload>
/**
 * Model Collection
 * 
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaContentType: {
  VIDEO: 'VIDEO',
  EXTERNAL_VIDEO: 'EXTERNAL_VIDEO',
  IMAGE: 'IMAGE',
  MODEL_3D: 'MODEL_3D'
};

export type MediaContentType = (typeof MediaContentType)[keyof typeof MediaContentType]

}

export type MediaContentType = $Enums.MediaContentType

export const MediaContentType: typeof $Enums.MediaContentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more FeaturedMediaVideos
 * const featuredMediaVideos = await prisma.featuredMediaVideo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more FeaturedMediaVideos
   * const featuredMediaVideos = await prisma.featuredMediaVideo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.featuredMediaVideo`: Exposes CRUD operations for the **FeaturedMediaVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedMediaVideos
    * const featuredMediaVideos = await prisma.featuredMediaVideo.findMany()
    * ```
    */
  get featuredMediaVideo(): Prisma.FeaturedMediaVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredMediaExternalVideo`: Exposes CRUD operations for the **FeaturedMediaExternalVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedMediaExternalVideos
    * const featuredMediaExternalVideos = await prisma.featuredMediaExternalVideo.findMany()
    * ```
    */
  get featuredMediaExternalVideo(): Prisma.FeaturedMediaExternalVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredMediaImage`: Exposes CRUD operations for the **FeaturedMediaImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedMediaImages
    * const featuredMediaImages = await prisma.featuredMediaImage.findMany()
    * ```
    */
  get featuredMediaImage(): Prisma.FeaturedMediaImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productFeaturedMedia`: Exposes CRUD operations for the **ProductFeaturedMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFeaturedMedias
    * const productFeaturedMedias = await prisma.productFeaturedMedia.findMany()
    * ```
    */
  get productFeaturedMedia(): Prisma.ProductFeaturedMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSEO`: Exposes CRUD operations for the **ProductSEO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSEOS
    * const productSEOS = await prisma.productSEO.findMany()
    * ```
    */
  get productSEO(): Prisma.ProductSEODelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariantProduct`: Exposes CRUD operations for the **ProductVariantProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariantProducts
    * const productVariantProducts = await prisma.productVariantProduct.findMany()
    * ```
    */
  get productVariantProduct(): Prisma.ProductVariantProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderPrice`: Exposes CRUD operations for the **OrderPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderPrices
    * const orderPrices = await prisma.orderPrice.findMany()
    * ```
    */
  get orderPrice(): Prisma.OrderPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionImage`: Exposes CRUD operations for the **CollectionImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionImages
    * const collectionImages = await prisma.collectionImage.findMany()
    * ```
    */
  get collectionImage(): Prisma.CollectionImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **Collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.CollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    FeaturedMediaVideo: 'FeaturedMediaVideo',
    FeaturedMediaExternalVideo: 'FeaturedMediaExternalVideo',
    FeaturedMediaImage: 'FeaturedMediaImage',
    ProductFeaturedMedia: 'ProductFeaturedMedia',
    ProductSEO: 'ProductSEO',
    ProductVariantProduct: 'ProductVariantProduct',
    ProductVariant: 'ProductVariant',
    Product: 'Product',
    OrderPrice: 'OrderPrice',
    Order: 'Order',
    CollectionImage: 'CollectionImage',
    Collection: 'Collection',
    Shop: 'Shop',
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "featuredMediaVideo" | "featuredMediaExternalVideo" | "featuredMediaImage" | "productFeaturedMedia" | "productSEO" | "productVariantProduct" | "productVariant" | "product" | "orderPrice" | "order" | "collectionImage" | "collection" | "shop" | "user" | "session" | "account" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      FeaturedMediaVideo: {
        payload: Prisma.$FeaturedMediaVideoPayload<ExtArgs>
        fields: Prisma.FeaturedMediaVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedMediaVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedMediaVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          findFirst: {
            args: Prisma.FeaturedMediaVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedMediaVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          findMany: {
            args: Prisma.FeaturedMediaVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>[]
          }
          create: {
            args: Prisma.FeaturedMediaVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          createMany: {
            args: Prisma.FeaturedMediaVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedMediaVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>[]
          }
          delete: {
            args: Prisma.FeaturedMediaVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          update: {
            args: Prisma.FeaturedMediaVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedMediaVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedMediaVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedMediaVideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>[]
          }
          upsert: {
            args: Prisma.FeaturedMediaVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaVideoPayload>
          }
          aggregate: {
            args: Prisma.FeaturedMediaVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedMediaVideo>
          }
          groupBy: {
            args: Prisma.FeaturedMediaVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedMediaVideoCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaVideoCountAggregateOutputType> | number
          }
        }
      }
      FeaturedMediaExternalVideo: {
        payload: Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>
        fields: Prisma.FeaturedMediaExternalVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedMediaExternalVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedMediaExternalVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          findFirst: {
            args: Prisma.FeaturedMediaExternalVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedMediaExternalVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          findMany: {
            args: Prisma.FeaturedMediaExternalVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>[]
          }
          create: {
            args: Prisma.FeaturedMediaExternalVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          createMany: {
            args: Prisma.FeaturedMediaExternalVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedMediaExternalVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>[]
          }
          delete: {
            args: Prisma.FeaturedMediaExternalVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          update: {
            args: Prisma.FeaturedMediaExternalVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedMediaExternalVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedMediaExternalVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedMediaExternalVideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>[]
          }
          upsert: {
            args: Prisma.FeaturedMediaExternalVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaExternalVideoPayload>
          }
          aggregate: {
            args: Prisma.FeaturedMediaExternalVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedMediaExternalVideo>
          }
          groupBy: {
            args: Prisma.FeaturedMediaExternalVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaExternalVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedMediaExternalVideoCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaExternalVideoCountAggregateOutputType> | number
          }
        }
      }
      FeaturedMediaImage: {
        payload: Prisma.$FeaturedMediaImagePayload<ExtArgs>
        fields: Prisma.FeaturedMediaImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedMediaImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedMediaImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          findFirst: {
            args: Prisma.FeaturedMediaImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedMediaImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          findMany: {
            args: Prisma.FeaturedMediaImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>[]
          }
          create: {
            args: Prisma.FeaturedMediaImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          createMany: {
            args: Prisma.FeaturedMediaImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedMediaImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>[]
          }
          delete: {
            args: Prisma.FeaturedMediaImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          update: {
            args: Prisma.FeaturedMediaImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          deleteMany: {
            args: Prisma.FeaturedMediaImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedMediaImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedMediaImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>[]
          }
          upsert: {
            args: Prisma.FeaturedMediaImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedMediaImagePayload>
          }
          aggregate: {
            args: Prisma.FeaturedMediaImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedMediaImage>
          }
          groupBy: {
            args: Prisma.FeaturedMediaImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedMediaImageCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedMediaImageCountAggregateOutputType> | number
          }
        }
      }
      ProductFeaturedMedia: {
        payload: Prisma.$ProductFeaturedMediaPayload<ExtArgs>
        fields: Prisma.ProductFeaturedMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFeaturedMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFeaturedMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          findFirst: {
            args: Prisma.ProductFeaturedMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFeaturedMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          findMany: {
            args: Prisma.ProductFeaturedMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>[]
          }
          create: {
            args: Prisma.ProductFeaturedMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          createMany: {
            args: Prisma.ProductFeaturedMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductFeaturedMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>[]
          }
          delete: {
            args: Prisma.ProductFeaturedMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          update: {
            args: Prisma.ProductFeaturedMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          deleteMany: {
            args: Prisma.ProductFeaturedMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductFeaturedMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductFeaturedMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>[]
          }
          upsert: {
            args: Prisma.ProductFeaturedMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFeaturedMediaPayload>
          }
          aggregate: {
            args: Prisma.ProductFeaturedMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductFeaturedMedia>
          }
          groupBy: {
            args: Prisma.ProductFeaturedMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductFeaturedMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductFeaturedMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ProductFeaturedMediaCountAggregateOutputType> | number
          }
        }
      }
      ProductSEO: {
        payload: Prisma.$ProductSEOPayload<ExtArgs>
        fields: Prisma.ProductSEOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSEOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSEOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          findFirst: {
            args: Prisma.ProductSEOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSEOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          findMany: {
            args: Prisma.ProductSEOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>[]
          }
          create: {
            args: Prisma.ProductSEOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          createMany: {
            args: Prisma.ProductSEOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductSEOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>[]
          }
          delete: {
            args: Prisma.ProductSEODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          update: {
            args: Prisma.ProductSEOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          deleteMany: {
            args: Prisma.ProductSEODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSEOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductSEOUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>[]
          }
          upsert: {
            args: Prisma.ProductSEOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSEOPayload>
          }
          aggregate: {
            args: Prisma.ProductSEOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSEO>
          }
          groupBy: {
            args: Prisma.ProductSEOGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSEOGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSEOCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSEOCountAggregateOutputType> | number
          }
        }
      }
      ProductVariantProduct: {
        payload: Prisma.$ProductVariantProductPayload<ExtArgs>
        fields: Prisma.ProductVariantProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          findMany: {
            args: Prisma.ProductVariantProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>[]
          }
          create: {
            args: Prisma.ProductVariantProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          createMany: {
            args: Prisma.ProductVariantProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          update: {
            args: Prisma.ProductVariantProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantProductPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariantProduct>
          }
          groupBy: {
            args: Prisma.ProductVariantProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      OrderPrice: {
        payload: Prisma.$OrderPricePayload<ExtArgs>
        fields: Prisma.OrderPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          findFirst: {
            args: Prisma.OrderPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          findMany: {
            args: Prisma.OrderPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>[]
          }
          create: {
            args: Prisma.OrderPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          createMany: {
            args: Prisma.OrderPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>[]
          }
          delete: {
            args: Prisma.OrderPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          update: {
            args: Prisma.OrderPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          deleteMany: {
            args: Prisma.OrderPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>[]
          }
          upsert: {
            args: Prisma.OrderPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPricePayload>
          }
          aggregate: {
            args: Prisma.OrderPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderPrice>
          }
          groupBy: {
            args: Prisma.OrderPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderPriceCountArgs<ExtArgs>
            result: $Utils.Optional<OrderPriceCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      CollectionImage: {
        payload: Prisma.$CollectionImagePayload<ExtArgs>
        fields: Prisma.CollectionImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          findFirst: {
            args: Prisma.CollectionImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          findMany: {
            args: Prisma.CollectionImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>[]
          }
          create: {
            args: Prisma.CollectionImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          createMany: {
            args: Prisma.CollectionImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>[]
          }
          delete: {
            args: Prisma.CollectionImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          update: {
            args: Prisma.CollectionImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          deleteMany: {
            args: Prisma.CollectionImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>[]
          }
          upsert: {
            args: Prisma.CollectionImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionImagePayload>
          }
          aggregate: {
            args: Prisma.CollectionImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionImage>
          }
          groupBy: {
            args: Prisma.CollectionImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionImageCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionImageCountAggregateOutputType> | number
          }
        }
      }
      Collection: {
        payload: Prisma.$CollectionPayload<ExtArgs>
        fields: Prisma.CollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findFirst: {
            args: Prisma.CollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findMany: {
            args: Prisma.CollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          create: {
            args: Prisma.CollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          createMany: {
            args: Prisma.CollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          delete: {
            args: Prisma.CollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          update: {
            args: Prisma.CollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          deleteMany: {
            args: Prisma.CollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          upsert: {
            args: Prisma.CollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection>
          }
          groupBy: {
            args: Prisma.CollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    featuredMediaVideo?: FeaturedMediaVideoOmit
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoOmit
    featuredMediaImage?: FeaturedMediaImageOmit
    productFeaturedMedia?: ProductFeaturedMediaOmit
    productSEO?: ProductSEOOmit
    productVariantProduct?: ProductVariantProductOmit
    productVariant?: ProductVariantOmit
    product?: ProductOmit
    orderPrice?: OrderPriceOmit
    order?: OrderOmit
    collectionImage?: CollectionImageOmit
    collection?: CollectionOmit
    shop?: ShopOmit
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    products: number
    orders: number
    collections: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ShopCountOutputTypeCountProductsArgs
    orders?: boolean | ShopCountOutputTypeCountOrdersArgs
    collections?: boolean | ShopCountOutputTypeCountCollectionsArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    shops: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    shops?: boolean | UserCountOutputTypeCountShopsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }


  /**
   * Models
   */

  /**
   * Model FeaturedMediaVideo
   */

  export type AggregateFeaturedMediaVideo = {
    _count: FeaturedMediaVideoCountAggregateOutputType | null
    _min: FeaturedMediaVideoMinAggregateOutputType | null
    _max: FeaturedMediaVideoMaxAggregateOutputType | null
  }

  export type FeaturedMediaVideoMinAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaVideoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaVideoCountAggregateOutputType = {
    id: number
    url: number
    productFeaturedMediaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedMediaVideoMinAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaVideoMaxAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaVideoCountAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedMediaVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaVideo to aggregate.
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaVideos to fetch.
     */
    orderBy?: FeaturedMediaVideoOrderByWithRelationInput | FeaturedMediaVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedMediaVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedMediaVideos
    **/
    _count?: true | FeaturedMediaVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedMediaVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedMediaVideoMaxAggregateInputType
  }

  export type GetFeaturedMediaVideoAggregateType<T extends FeaturedMediaVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedMediaVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedMediaVideo[P]>
      : GetScalarType<T[P], AggregateFeaturedMediaVideo[P]>
  }




  export type FeaturedMediaVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedMediaVideoWhereInput
    orderBy?: FeaturedMediaVideoOrderByWithAggregationInput | FeaturedMediaVideoOrderByWithAggregationInput[]
    by: FeaturedMediaVideoScalarFieldEnum[] | FeaturedMediaVideoScalarFieldEnum
    having?: FeaturedMediaVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedMediaVideoCountAggregateInputType | true
    _min?: FeaturedMediaVideoMinAggregateInputType
    _max?: FeaturedMediaVideoMaxAggregateInputType
  }

  export type FeaturedMediaVideoGroupByOutputType = {
    id: string
    url: string
    productFeaturedMediaId: string
    createdAt: Date
    updatedAt: Date
    _count: FeaturedMediaVideoCountAggregateOutputType | null
    _min: FeaturedMediaVideoMinAggregateOutputType | null
    _max: FeaturedMediaVideoMaxAggregateOutputType | null
  }

  type GetFeaturedMediaVideoGroupByPayload<T extends FeaturedMediaVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedMediaVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedMediaVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedMediaVideoGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedMediaVideoGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedMediaVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaVideo"]>

  export type FeaturedMediaVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaVideo"]>

  export type FeaturedMediaVideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaVideo"]>

  export type FeaturedMediaVideoSelectScalar = {
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedMediaVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "productFeaturedMediaId" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredMediaVideo"]>
  export type FeaturedMediaVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaVideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }

  export type $FeaturedMediaVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedMediaVideo"
    objects: {
      productFeaturedMedia: Prisma.$ProductFeaturedMediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      productFeaturedMediaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredMediaVideo"]>
    composites: {}
  }

  type FeaturedMediaVideoGetPayload<S extends boolean | null | undefined | FeaturedMediaVideoDefaultArgs> = $Result.GetResult<Prisma.$FeaturedMediaVideoPayload, S>

  type FeaturedMediaVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedMediaVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedMediaVideoCountAggregateInputType | true
    }

  export interface FeaturedMediaVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedMediaVideo'], meta: { name: 'FeaturedMediaVideo' } }
    /**
     * Find zero or one FeaturedMediaVideo that matches the filter.
     * @param {FeaturedMediaVideoFindUniqueArgs} args - Arguments to find a FeaturedMediaVideo
     * @example
     * // Get one FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedMediaVideoFindUniqueArgs>(args: SelectSubset<T, FeaturedMediaVideoFindUniqueArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedMediaVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedMediaVideoFindUniqueOrThrowArgs} args - Arguments to find a FeaturedMediaVideo
     * @example
     * // Get one FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedMediaVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedMediaVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoFindFirstArgs} args - Arguments to find a FeaturedMediaVideo
     * @example
     * // Get one FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedMediaVideoFindFirstArgs>(args?: SelectSubset<T, FeaturedMediaVideoFindFirstArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoFindFirstOrThrowArgs} args - Arguments to find a FeaturedMediaVideo
     * @example
     * // Get one FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedMediaVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedMediaVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedMediaVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedMediaVideos
     * const featuredMediaVideos = await prisma.featuredMediaVideo.findMany()
     * 
     * // Get first 10 FeaturedMediaVideos
     * const featuredMediaVideos = await prisma.featuredMediaVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredMediaVideoWithIdOnly = await prisma.featuredMediaVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedMediaVideoFindManyArgs>(args?: SelectSubset<T, FeaturedMediaVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedMediaVideo.
     * @param {FeaturedMediaVideoCreateArgs} args - Arguments to create a FeaturedMediaVideo.
     * @example
     * // Create one FeaturedMediaVideo
     * const FeaturedMediaVideo = await prisma.featuredMediaVideo.create({
     *   data: {
     *     // ... data to create a FeaturedMediaVideo
     *   }
     * })
     * 
     */
    create<T extends FeaturedMediaVideoCreateArgs>(args: SelectSubset<T, FeaturedMediaVideoCreateArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedMediaVideos.
     * @param {FeaturedMediaVideoCreateManyArgs} args - Arguments to create many FeaturedMediaVideos.
     * @example
     * // Create many FeaturedMediaVideos
     * const featuredMediaVideo = await prisma.featuredMediaVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedMediaVideoCreateManyArgs>(args?: SelectSubset<T, FeaturedMediaVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedMediaVideos and returns the data saved in the database.
     * @param {FeaturedMediaVideoCreateManyAndReturnArgs} args - Arguments to create many FeaturedMediaVideos.
     * @example
     * // Create many FeaturedMediaVideos
     * const featuredMediaVideo = await prisma.featuredMediaVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedMediaVideos and only return the `id`
     * const featuredMediaVideoWithIdOnly = await prisma.featuredMediaVideo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedMediaVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedMediaVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedMediaVideo.
     * @param {FeaturedMediaVideoDeleteArgs} args - Arguments to delete one FeaturedMediaVideo.
     * @example
     * // Delete one FeaturedMediaVideo
     * const FeaturedMediaVideo = await prisma.featuredMediaVideo.delete({
     *   where: {
     *     // ... filter to delete one FeaturedMediaVideo
     *   }
     * })
     * 
     */
    delete<T extends FeaturedMediaVideoDeleteArgs>(args: SelectSubset<T, FeaturedMediaVideoDeleteArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedMediaVideo.
     * @param {FeaturedMediaVideoUpdateArgs} args - Arguments to update one FeaturedMediaVideo.
     * @example
     * // Update one FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedMediaVideoUpdateArgs>(args: SelectSubset<T, FeaturedMediaVideoUpdateArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedMediaVideos.
     * @param {FeaturedMediaVideoDeleteManyArgs} args - Arguments to filter FeaturedMediaVideos to delete.
     * @example
     * // Delete a few FeaturedMediaVideos
     * const { count } = await prisma.featuredMediaVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedMediaVideoDeleteManyArgs>(args?: SelectSubset<T, FeaturedMediaVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedMediaVideos
     * const featuredMediaVideo = await prisma.featuredMediaVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedMediaVideoUpdateManyArgs>(args: SelectSubset<T, FeaturedMediaVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaVideos and returns the data updated in the database.
     * @param {FeaturedMediaVideoUpdateManyAndReturnArgs} args - Arguments to update many FeaturedMediaVideos.
     * @example
     * // Update many FeaturedMediaVideos
     * const featuredMediaVideo = await prisma.featuredMediaVideo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedMediaVideos and only return the `id`
     * const featuredMediaVideoWithIdOnly = await prisma.featuredMediaVideo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedMediaVideoUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedMediaVideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedMediaVideo.
     * @param {FeaturedMediaVideoUpsertArgs} args - Arguments to update or create a FeaturedMediaVideo.
     * @example
     * // Update or create a FeaturedMediaVideo
     * const featuredMediaVideo = await prisma.featuredMediaVideo.upsert({
     *   create: {
     *     // ... data to create a FeaturedMediaVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedMediaVideo we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedMediaVideoUpsertArgs>(args: SelectSubset<T, FeaturedMediaVideoUpsertArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedMediaVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoCountArgs} args - Arguments to filter FeaturedMediaVideos to count.
     * @example
     * // Count the number of FeaturedMediaVideos
     * const count = await prisma.featuredMediaVideo.count({
     *   where: {
     *     // ... the filter for the FeaturedMediaVideos we want to count
     *   }
     * })
    **/
    count<T extends FeaturedMediaVideoCountArgs>(
      args?: Subset<T, FeaturedMediaVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedMediaVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedMediaVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedMediaVideoAggregateArgs>(args: Subset<T, FeaturedMediaVideoAggregateArgs>): Prisma.PrismaPromise<GetFeaturedMediaVideoAggregateType<T>>

    /**
     * Group by FeaturedMediaVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedMediaVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedMediaVideoGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedMediaVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedMediaVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedMediaVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedMediaVideo model
   */
  readonly fields: FeaturedMediaVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedMediaVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedMediaVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productFeaturedMedia<T extends ProductFeaturedMediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMediaDefaultArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedMediaVideo model
   */ 
  interface FeaturedMediaVideoFieldRefs {
    readonly id: FieldRef<"FeaturedMediaVideo", 'String'>
    readonly url: FieldRef<"FeaturedMediaVideo", 'String'>
    readonly productFeaturedMediaId: FieldRef<"FeaturedMediaVideo", 'String'>
    readonly createdAt: FieldRef<"FeaturedMediaVideo", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedMediaVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedMediaVideo findUnique
   */
  export type FeaturedMediaVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaVideo to fetch.
     */
    where: FeaturedMediaVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaVideo findUniqueOrThrow
   */
  export type FeaturedMediaVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaVideo to fetch.
     */
    where: FeaturedMediaVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaVideo findFirst
   */
  export type FeaturedMediaVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaVideo to fetch.
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaVideos to fetch.
     */
    orderBy?: FeaturedMediaVideoOrderByWithRelationInput | FeaturedMediaVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaVideos.
     */
    cursor?: FeaturedMediaVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaVideos.
     */
    distinct?: FeaturedMediaVideoScalarFieldEnum | FeaturedMediaVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaVideo findFirstOrThrow
   */
  export type FeaturedMediaVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaVideo to fetch.
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaVideos to fetch.
     */
    orderBy?: FeaturedMediaVideoOrderByWithRelationInput | FeaturedMediaVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaVideos.
     */
    cursor?: FeaturedMediaVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaVideos.
     */
    distinct?: FeaturedMediaVideoScalarFieldEnum | FeaturedMediaVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaVideo findMany
   */
  export type FeaturedMediaVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaVideos to fetch.
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaVideos to fetch.
     */
    orderBy?: FeaturedMediaVideoOrderByWithRelationInput | FeaturedMediaVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedMediaVideos.
     */
    cursor?: FeaturedMediaVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaVideos.
     */
    skip?: number
    distinct?: FeaturedMediaVideoScalarFieldEnum | FeaturedMediaVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaVideo create
   */
  export type FeaturedMediaVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedMediaVideo.
     */
    data: XOR<FeaturedMediaVideoCreateInput, FeaturedMediaVideoUncheckedCreateInput>
  }

  /**
   * FeaturedMediaVideo createMany
   */
  export type FeaturedMediaVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedMediaVideos.
     */
    data: FeaturedMediaVideoCreateManyInput | FeaturedMediaVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedMediaVideo createManyAndReturn
   */
  export type FeaturedMediaVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedMediaVideos.
     */
    data: FeaturedMediaVideoCreateManyInput | FeaturedMediaVideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaVideo update
   */
  export type FeaturedMediaVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedMediaVideo.
     */
    data: XOR<FeaturedMediaVideoUpdateInput, FeaturedMediaVideoUncheckedUpdateInput>
    /**
     * Choose, which FeaturedMediaVideo to update.
     */
    where: FeaturedMediaVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaVideo updateMany
   */
  export type FeaturedMediaVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedMediaVideos.
     */
    data: XOR<FeaturedMediaVideoUpdateManyMutationInput, FeaturedMediaVideoUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaVideos to update
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * Limit how many FeaturedMediaVideos to update.
     */
    limit?: number
  }

  /**
   * FeaturedMediaVideo updateManyAndReturn
   */
  export type FeaturedMediaVideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedMediaVideos.
     */
    data: XOR<FeaturedMediaVideoUpdateManyMutationInput, FeaturedMediaVideoUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaVideos to update
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * Limit how many FeaturedMediaVideos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaVideo upsert
   */
  export type FeaturedMediaVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedMediaVideo to update in case it exists.
     */
    where: FeaturedMediaVideoWhereUniqueInput
    /**
     * In case the FeaturedMediaVideo found by the `where` argument doesn't exist, create a new FeaturedMediaVideo with this data.
     */
    create: XOR<FeaturedMediaVideoCreateInput, FeaturedMediaVideoUncheckedCreateInput>
    /**
     * In case the FeaturedMediaVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedMediaVideoUpdateInput, FeaturedMediaVideoUncheckedUpdateInput>
  }

  /**
   * FeaturedMediaVideo delete
   */
  export type FeaturedMediaVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    /**
     * Filter which FeaturedMediaVideo to delete.
     */
    where: FeaturedMediaVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaVideo deleteMany
   */
  export type FeaturedMediaVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaVideos to delete
     */
    where?: FeaturedMediaVideoWhereInput
    /**
     * Limit how many FeaturedMediaVideos to delete.
     */
    limit?: number
  }

  /**
   * FeaturedMediaVideo without action
   */
  export type FeaturedMediaVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedMediaExternalVideo
   */

  export type AggregateFeaturedMediaExternalVideo = {
    _count: FeaturedMediaExternalVideoCountAggregateOutputType | null
    _min: FeaturedMediaExternalVideoMinAggregateOutputType | null
    _max: FeaturedMediaExternalVideoMaxAggregateOutputType | null
  }

  export type FeaturedMediaExternalVideoMinAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaExternalVideoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaExternalVideoCountAggregateOutputType = {
    id: number
    url: number
    productFeaturedMediaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedMediaExternalVideoMinAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaExternalVideoMaxAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaExternalVideoCountAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedMediaExternalVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaExternalVideo to aggregate.
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaExternalVideos to fetch.
     */
    orderBy?: FeaturedMediaExternalVideoOrderByWithRelationInput | FeaturedMediaExternalVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedMediaExternalVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaExternalVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaExternalVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedMediaExternalVideos
    **/
    _count?: true | FeaturedMediaExternalVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedMediaExternalVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedMediaExternalVideoMaxAggregateInputType
  }

  export type GetFeaturedMediaExternalVideoAggregateType<T extends FeaturedMediaExternalVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedMediaExternalVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedMediaExternalVideo[P]>
      : GetScalarType<T[P], AggregateFeaturedMediaExternalVideo[P]>
  }




  export type FeaturedMediaExternalVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedMediaExternalVideoWhereInput
    orderBy?: FeaturedMediaExternalVideoOrderByWithAggregationInput | FeaturedMediaExternalVideoOrderByWithAggregationInput[]
    by: FeaturedMediaExternalVideoScalarFieldEnum[] | FeaturedMediaExternalVideoScalarFieldEnum
    having?: FeaturedMediaExternalVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedMediaExternalVideoCountAggregateInputType | true
    _min?: FeaturedMediaExternalVideoMinAggregateInputType
    _max?: FeaturedMediaExternalVideoMaxAggregateInputType
  }

  export type FeaturedMediaExternalVideoGroupByOutputType = {
    id: string
    url: string
    productFeaturedMediaId: string
    createdAt: Date
    updatedAt: Date
    _count: FeaturedMediaExternalVideoCountAggregateOutputType | null
    _min: FeaturedMediaExternalVideoMinAggregateOutputType | null
    _max: FeaturedMediaExternalVideoMaxAggregateOutputType | null
  }

  type GetFeaturedMediaExternalVideoGroupByPayload<T extends FeaturedMediaExternalVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedMediaExternalVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedMediaExternalVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedMediaExternalVideoGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedMediaExternalVideoGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedMediaExternalVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaExternalVideo"]>

  export type FeaturedMediaExternalVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaExternalVideo"]>

  export type FeaturedMediaExternalVideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaExternalVideo"]>

  export type FeaturedMediaExternalVideoSelectScalar = {
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedMediaExternalVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "productFeaturedMediaId" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredMediaExternalVideo"]>
  export type FeaturedMediaExternalVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaExternalVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaExternalVideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }

  export type $FeaturedMediaExternalVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedMediaExternalVideo"
    objects: {
      productFeaturedMedia: Prisma.$ProductFeaturedMediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      productFeaturedMediaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredMediaExternalVideo"]>
    composites: {}
  }

  type FeaturedMediaExternalVideoGetPayload<S extends boolean | null | undefined | FeaturedMediaExternalVideoDefaultArgs> = $Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload, S>

  type FeaturedMediaExternalVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedMediaExternalVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedMediaExternalVideoCountAggregateInputType | true
    }

  export interface FeaturedMediaExternalVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedMediaExternalVideo'], meta: { name: 'FeaturedMediaExternalVideo' } }
    /**
     * Find zero or one FeaturedMediaExternalVideo that matches the filter.
     * @param {FeaturedMediaExternalVideoFindUniqueArgs} args - Arguments to find a FeaturedMediaExternalVideo
     * @example
     * // Get one FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedMediaExternalVideoFindUniqueArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoFindUniqueArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedMediaExternalVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedMediaExternalVideoFindUniqueOrThrowArgs} args - Arguments to find a FeaturedMediaExternalVideo
     * @example
     * // Get one FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedMediaExternalVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaExternalVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoFindFirstArgs} args - Arguments to find a FeaturedMediaExternalVideo
     * @example
     * // Get one FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedMediaExternalVideoFindFirstArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoFindFirstArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaExternalVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoFindFirstOrThrowArgs} args - Arguments to find a FeaturedMediaExternalVideo
     * @example
     * // Get one FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedMediaExternalVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedMediaExternalVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedMediaExternalVideos
     * const featuredMediaExternalVideos = await prisma.featuredMediaExternalVideo.findMany()
     * 
     * // Get first 10 FeaturedMediaExternalVideos
     * const featuredMediaExternalVideos = await prisma.featuredMediaExternalVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredMediaExternalVideoWithIdOnly = await prisma.featuredMediaExternalVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedMediaExternalVideoFindManyArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedMediaExternalVideo.
     * @param {FeaturedMediaExternalVideoCreateArgs} args - Arguments to create a FeaturedMediaExternalVideo.
     * @example
     * // Create one FeaturedMediaExternalVideo
     * const FeaturedMediaExternalVideo = await prisma.featuredMediaExternalVideo.create({
     *   data: {
     *     // ... data to create a FeaturedMediaExternalVideo
     *   }
     * })
     * 
     */
    create<T extends FeaturedMediaExternalVideoCreateArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoCreateArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedMediaExternalVideos.
     * @param {FeaturedMediaExternalVideoCreateManyArgs} args - Arguments to create many FeaturedMediaExternalVideos.
     * @example
     * // Create many FeaturedMediaExternalVideos
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedMediaExternalVideoCreateManyArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedMediaExternalVideos and returns the data saved in the database.
     * @param {FeaturedMediaExternalVideoCreateManyAndReturnArgs} args - Arguments to create many FeaturedMediaExternalVideos.
     * @example
     * // Create many FeaturedMediaExternalVideos
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedMediaExternalVideos and only return the `id`
     * const featuredMediaExternalVideoWithIdOnly = await prisma.featuredMediaExternalVideo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedMediaExternalVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedMediaExternalVideo.
     * @param {FeaturedMediaExternalVideoDeleteArgs} args - Arguments to delete one FeaturedMediaExternalVideo.
     * @example
     * // Delete one FeaturedMediaExternalVideo
     * const FeaturedMediaExternalVideo = await prisma.featuredMediaExternalVideo.delete({
     *   where: {
     *     // ... filter to delete one FeaturedMediaExternalVideo
     *   }
     * })
     * 
     */
    delete<T extends FeaturedMediaExternalVideoDeleteArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoDeleteArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedMediaExternalVideo.
     * @param {FeaturedMediaExternalVideoUpdateArgs} args - Arguments to update one FeaturedMediaExternalVideo.
     * @example
     * // Update one FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedMediaExternalVideoUpdateArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoUpdateArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedMediaExternalVideos.
     * @param {FeaturedMediaExternalVideoDeleteManyArgs} args - Arguments to filter FeaturedMediaExternalVideos to delete.
     * @example
     * // Delete a few FeaturedMediaExternalVideos
     * const { count } = await prisma.featuredMediaExternalVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedMediaExternalVideoDeleteManyArgs>(args?: SelectSubset<T, FeaturedMediaExternalVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaExternalVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedMediaExternalVideos
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedMediaExternalVideoUpdateManyArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaExternalVideos and returns the data updated in the database.
     * @param {FeaturedMediaExternalVideoUpdateManyAndReturnArgs} args - Arguments to update many FeaturedMediaExternalVideos.
     * @example
     * // Update many FeaturedMediaExternalVideos
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedMediaExternalVideos and only return the `id`
     * const featuredMediaExternalVideoWithIdOnly = await prisma.featuredMediaExternalVideo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedMediaExternalVideoUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedMediaExternalVideo.
     * @param {FeaturedMediaExternalVideoUpsertArgs} args - Arguments to update or create a FeaturedMediaExternalVideo.
     * @example
     * // Update or create a FeaturedMediaExternalVideo
     * const featuredMediaExternalVideo = await prisma.featuredMediaExternalVideo.upsert({
     *   create: {
     *     // ... data to create a FeaturedMediaExternalVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedMediaExternalVideo we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedMediaExternalVideoUpsertArgs>(args: SelectSubset<T, FeaturedMediaExternalVideoUpsertArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedMediaExternalVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoCountArgs} args - Arguments to filter FeaturedMediaExternalVideos to count.
     * @example
     * // Count the number of FeaturedMediaExternalVideos
     * const count = await prisma.featuredMediaExternalVideo.count({
     *   where: {
     *     // ... the filter for the FeaturedMediaExternalVideos we want to count
     *   }
     * })
    **/
    count<T extends FeaturedMediaExternalVideoCountArgs>(
      args?: Subset<T, FeaturedMediaExternalVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedMediaExternalVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedMediaExternalVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedMediaExternalVideoAggregateArgs>(args: Subset<T, FeaturedMediaExternalVideoAggregateArgs>): Prisma.PrismaPromise<GetFeaturedMediaExternalVideoAggregateType<T>>

    /**
     * Group by FeaturedMediaExternalVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaExternalVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedMediaExternalVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedMediaExternalVideoGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedMediaExternalVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedMediaExternalVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedMediaExternalVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedMediaExternalVideo model
   */
  readonly fields: FeaturedMediaExternalVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedMediaExternalVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedMediaExternalVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productFeaturedMedia<T extends ProductFeaturedMediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMediaDefaultArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedMediaExternalVideo model
   */ 
  interface FeaturedMediaExternalVideoFieldRefs {
    readonly id: FieldRef<"FeaturedMediaExternalVideo", 'String'>
    readonly url: FieldRef<"FeaturedMediaExternalVideo", 'String'>
    readonly productFeaturedMediaId: FieldRef<"FeaturedMediaExternalVideo", 'String'>
    readonly createdAt: FieldRef<"FeaturedMediaExternalVideo", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedMediaExternalVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedMediaExternalVideo findUnique
   */
  export type FeaturedMediaExternalVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaExternalVideo to fetch.
     */
    where: FeaturedMediaExternalVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaExternalVideo findUniqueOrThrow
   */
  export type FeaturedMediaExternalVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaExternalVideo to fetch.
     */
    where: FeaturedMediaExternalVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaExternalVideo findFirst
   */
  export type FeaturedMediaExternalVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaExternalVideo to fetch.
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaExternalVideos to fetch.
     */
    orderBy?: FeaturedMediaExternalVideoOrderByWithRelationInput | FeaturedMediaExternalVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaExternalVideos.
     */
    cursor?: FeaturedMediaExternalVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaExternalVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaExternalVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaExternalVideos.
     */
    distinct?: FeaturedMediaExternalVideoScalarFieldEnum | FeaturedMediaExternalVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaExternalVideo findFirstOrThrow
   */
  export type FeaturedMediaExternalVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaExternalVideo to fetch.
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaExternalVideos to fetch.
     */
    orderBy?: FeaturedMediaExternalVideoOrderByWithRelationInput | FeaturedMediaExternalVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaExternalVideos.
     */
    cursor?: FeaturedMediaExternalVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaExternalVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaExternalVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaExternalVideos.
     */
    distinct?: FeaturedMediaExternalVideoScalarFieldEnum | FeaturedMediaExternalVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaExternalVideo findMany
   */
  export type FeaturedMediaExternalVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaExternalVideos to fetch.
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaExternalVideos to fetch.
     */
    orderBy?: FeaturedMediaExternalVideoOrderByWithRelationInput | FeaturedMediaExternalVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedMediaExternalVideos.
     */
    cursor?: FeaturedMediaExternalVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaExternalVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaExternalVideos.
     */
    skip?: number
    distinct?: FeaturedMediaExternalVideoScalarFieldEnum | FeaturedMediaExternalVideoScalarFieldEnum[]
  }

  /**
   * FeaturedMediaExternalVideo create
   */
  export type FeaturedMediaExternalVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedMediaExternalVideo.
     */
    data: XOR<FeaturedMediaExternalVideoCreateInput, FeaturedMediaExternalVideoUncheckedCreateInput>
  }

  /**
   * FeaturedMediaExternalVideo createMany
   */
  export type FeaturedMediaExternalVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedMediaExternalVideos.
     */
    data: FeaturedMediaExternalVideoCreateManyInput | FeaturedMediaExternalVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedMediaExternalVideo createManyAndReturn
   */
  export type FeaturedMediaExternalVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedMediaExternalVideos.
     */
    data: FeaturedMediaExternalVideoCreateManyInput | FeaturedMediaExternalVideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaExternalVideo update
   */
  export type FeaturedMediaExternalVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedMediaExternalVideo.
     */
    data: XOR<FeaturedMediaExternalVideoUpdateInput, FeaturedMediaExternalVideoUncheckedUpdateInput>
    /**
     * Choose, which FeaturedMediaExternalVideo to update.
     */
    where: FeaturedMediaExternalVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaExternalVideo updateMany
   */
  export type FeaturedMediaExternalVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedMediaExternalVideos.
     */
    data: XOR<FeaturedMediaExternalVideoUpdateManyMutationInput, FeaturedMediaExternalVideoUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaExternalVideos to update
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * Limit how many FeaturedMediaExternalVideos to update.
     */
    limit?: number
  }

  /**
   * FeaturedMediaExternalVideo updateManyAndReturn
   */
  export type FeaturedMediaExternalVideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedMediaExternalVideos.
     */
    data: XOR<FeaturedMediaExternalVideoUpdateManyMutationInput, FeaturedMediaExternalVideoUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaExternalVideos to update
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * Limit how many FeaturedMediaExternalVideos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaExternalVideo upsert
   */
  export type FeaturedMediaExternalVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedMediaExternalVideo to update in case it exists.
     */
    where: FeaturedMediaExternalVideoWhereUniqueInput
    /**
     * In case the FeaturedMediaExternalVideo found by the `where` argument doesn't exist, create a new FeaturedMediaExternalVideo with this data.
     */
    create: XOR<FeaturedMediaExternalVideoCreateInput, FeaturedMediaExternalVideoUncheckedCreateInput>
    /**
     * In case the FeaturedMediaExternalVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedMediaExternalVideoUpdateInput, FeaturedMediaExternalVideoUncheckedUpdateInput>
  }

  /**
   * FeaturedMediaExternalVideo delete
   */
  export type FeaturedMediaExternalVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    /**
     * Filter which FeaturedMediaExternalVideo to delete.
     */
    where: FeaturedMediaExternalVideoWhereUniqueInput
  }

  /**
   * FeaturedMediaExternalVideo deleteMany
   */
  export type FeaturedMediaExternalVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaExternalVideos to delete
     */
    where?: FeaturedMediaExternalVideoWhereInput
    /**
     * Limit how many FeaturedMediaExternalVideos to delete.
     */
    limit?: number
  }

  /**
   * FeaturedMediaExternalVideo without action
   */
  export type FeaturedMediaExternalVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedMediaImage
   */

  export type AggregateFeaturedMediaImage = {
    _count: FeaturedMediaImageCountAggregateOutputType | null
    _min: FeaturedMediaImageMinAggregateOutputType | null
    _max: FeaturedMediaImageMaxAggregateOutputType | null
  }

  export type FeaturedMediaImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    productFeaturedMediaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedMediaImageCountAggregateOutputType = {
    id: number
    url: number
    productFeaturedMediaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedMediaImageMinAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaImageMaxAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedMediaImageCountAggregateInputType = {
    id?: true
    url?: true
    productFeaturedMediaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedMediaImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaImage to aggregate.
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaImages to fetch.
     */
    orderBy?: FeaturedMediaImageOrderByWithRelationInput | FeaturedMediaImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedMediaImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedMediaImages
    **/
    _count?: true | FeaturedMediaImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedMediaImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedMediaImageMaxAggregateInputType
  }

  export type GetFeaturedMediaImageAggregateType<T extends FeaturedMediaImageAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedMediaImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedMediaImage[P]>
      : GetScalarType<T[P], AggregateFeaturedMediaImage[P]>
  }




  export type FeaturedMediaImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedMediaImageWhereInput
    orderBy?: FeaturedMediaImageOrderByWithAggregationInput | FeaturedMediaImageOrderByWithAggregationInput[]
    by: FeaturedMediaImageScalarFieldEnum[] | FeaturedMediaImageScalarFieldEnum
    having?: FeaturedMediaImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedMediaImageCountAggregateInputType | true
    _min?: FeaturedMediaImageMinAggregateInputType
    _max?: FeaturedMediaImageMaxAggregateInputType
  }

  export type FeaturedMediaImageGroupByOutputType = {
    id: string
    url: string
    productFeaturedMediaId: string
    createdAt: Date
    updatedAt: Date
    _count: FeaturedMediaImageCountAggregateOutputType | null
    _min: FeaturedMediaImageMinAggregateOutputType | null
    _max: FeaturedMediaImageMaxAggregateOutputType | null
  }

  type GetFeaturedMediaImageGroupByPayload<T extends FeaturedMediaImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedMediaImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedMediaImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedMediaImageGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedMediaImageGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedMediaImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaImage"]>

  export type FeaturedMediaImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaImage"]>

  export type FeaturedMediaImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredMediaImage"]>

  export type FeaturedMediaImageSelectScalar = {
    id?: boolean
    url?: boolean
    productFeaturedMediaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedMediaImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "productFeaturedMediaId" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredMediaImage"]>
  export type FeaturedMediaImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }
  export type FeaturedMediaImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productFeaturedMedia?: boolean | ProductFeaturedMediaDefaultArgs<ExtArgs>
  }

  export type $FeaturedMediaImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedMediaImage"
    objects: {
      productFeaturedMedia: Prisma.$ProductFeaturedMediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      productFeaturedMediaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredMediaImage"]>
    composites: {}
  }

  type FeaturedMediaImageGetPayload<S extends boolean | null | undefined | FeaturedMediaImageDefaultArgs> = $Result.GetResult<Prisma.$FeaturedMediaImagePayload, S>

  type FeaturedMediaImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedMediaImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedMediaImageCountAggregateInputType | true
    }

  export interface FeaturedMediaImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedMediaImage'], meta: { name: 'FeaturedMediaImage' } }
    /**
     * Find zero or one FeaturedMediaImage that matches the filter.
     * @param {FeaturedMediaImageFindUniqueArgs} args - Arguments to find a FeaturedMediaImage
     * @example
     * // Get one FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedMediaImageFindUniqueArgs>(args: SelectSubset<T, FeaturedMediaImageFindUniqueArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedMediaImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedMediaImageFindUniqueOrThrowArgs} args - Arguments to find a FeaturedMediaImage
     * @example
     * // Get one FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedMediaImageFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedMediaImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageFindFirstArgs} args - Arguments to find a FeaturedMediaImage
     * @example
     * // Get one FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedMediaImageFindFirstArgs>(args?: SelectSubset<T, FeaturedMediaImageFindFirstArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedMediaImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageFindFirstOrThrowArgs} args - Arguments to find a FeaturedMediaImage
     * @example
     * // Get one FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedMediaImageFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedMediaImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedMediaImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedMediaImages
     * const featuredMediaImages = await prisma.featuredMediaImage.findMany()
     * 
     * // Get first 10 FeaturedMediaImages
     * const featuredMediaImages = await prisma.featuredMediaImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredMediaImageWithIdOnly = await prisma.featuredMediaImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedMediaImageFindManyArgs>(args?: SelectSubset<T, FeaturedMediaImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedMediaImage.
     * @param {FeaturedMediaImageCreateArgs} args - Arguments to create a FeaturedMediaImage.
     * @example
     * // Create one FeaturedMediaImage
     * const FeaturedMediaImage = await prisma.featuredMediaImage.create({
     *   data: {
     *     // ... data to create a FeaturedMediaImage
     *   }
     * })
     * 
     */
    create<T extends FeaturedMediaImageCreateArgs>(args: SelectSubset<T, FeaturedMediaImageCreateArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedMediaImages.
     * @param {FeaturedMediaImageCreateManyArgs} args - Arguments to create many FeaturedMediaImages.
     * @example
     * // Create many FeaturedMediaImages
     * const featuredMediaImage = await prisma.featuredMediaImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedMediaImageCreateManyArgs>(args?: SelectSubset<T, FeaturedMediaImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedMediaImages and returns the data saved in the database.
     * @param {FeaturedMediaImageCreateManyAndReturnArgs} args - Arguments to create many FeaturedMediaImages.
     * @example
     * // Create many FeaturedMediaImages
     * const featuredMediaImage = await prisma.featuredMediaImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedMediaImages and only return the `id`
     * const featuredMediaImageWithIdOnly = await prisma.featuredMediaImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedMediaImageCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedMediaImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedMediaImage.
     * @param {FeaturedMediaImageDeleteArgs} args - Arguments to delete one FeaturedMediaImage.
     * @example
     * // Delete one FeaturedMediaImage
     * const FeaturedMediaImage = await prisma.featuredMediaImage.delete({
     *   where: {
     *     // ... filter to delete one FeaturedMediaImage
     *   }
     * })
     * 
     */
    delete<T extends FeaturedMediaImageDeleteArgs>(args: SelectSubset<T, FeaturedMediaImageDeleteArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedMediaImage.
     * @param {FeaturedMediaImageUpdateArgs} args - Arguments to update one FeaturedMediaImage.
     * @example
     * // Update one FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedMediaImageUpdateArgs>(args: SelectSubset<T, FeaturedMediaImageUpdateArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedMediaImages.
     * @param {FeaturedMediaImageDeleteManyArgs} args - Arguments to filter FeaturedMediaImages to delete.
     * @example
     * // Delete a few FeaturedMediaImages
     * const { count } = await prisma.featuredMediaImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedMediaImageDeleteManyArgs>(args?: SelectSubset<T, FeaturedMediaImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedMediaImages
     * const featuredMediaImage = await prisma.featuredMediaImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedMediaImageUpdateManyArgs>(args: SelectSubset<T, FeaturedMediaImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedMediaImages and returns the data updated in the database.
     * @param {FeaturedMediaImageUpdateManyAndReturnArgs} args - Arguments to update many FeaturedMediaImages.
     * @example
     * // Update many FeaturedMediaImages
     * const featuredMediaImage = await prisma.featuredMediaImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedMediaImages and only return the `id`
     * const featuredMediaImageWithIdOnly = await prisma.featuredMediaImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedMediaImageUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedMediaImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedMediaImage.
     * @param {FeaturedMediaImageUpsertArgs} args - Arguments to update or create a FeaturedMediaImage.
     * @example
     * // Update or create a FeaturedMediaImage
     * const featuredMediaImage = await prisma.featuredMediaImage.upsert({
     *   create: {
     *     // ... data to create a FeaturedMediaImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedMediaImage we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedMediaImageUpsertArgs>(args: SelectSubset<T, FeaturedMediaImageUpsertArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedMediaImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageCountArgs} args - Arguments to filter FeaturedMediaImages to count.
     * @example
     * // Count the number of FeaturedMediaImages
     * const count = await prisma.featuredMediaImage.count({
     *   where: {
     *     // ... the filter for the FeaturedMediaImages we want to count
     *   }
     * })
    **/
    count<T extends FeaturedMediaImageCountArgs>(
      args?: Subset<T, FeaturedMediaImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedMediaImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedMediaImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedMediaImageAggregateArgs>(args: Subset<T, FeaturedMediaImageAggregateArgs>): Prisma.PrismaPromise<GetFeaturedMediaImageAggregateType<T>>

    /**
     * Group by FeaturedMediaImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedMediaImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedMediaImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedMediaImageGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedMediaImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedMediaImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedMediaImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedMediaImage model
   */
  readonly fields: FeaturedMediaImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedMediaImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedMediaImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productFeaturedMedia<T extends ProductFeaturedMediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMediaDefaultArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedMediaImage model
   */ 
  interface FeaturedMediaImageFieldRefs {
    readonly id: FieldRef<"FeaturedMediaImage", 'String'>
    readonly url: FieldRef<"FeaturedMediaImage", 'String'>
    readonly productFeaturedMediaId: FieldRef<"FeaturedMediaImage", 'String'>
    readonly createdAt: FieldRef<"FeaturedMediaImage", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedMediaImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedMediaImage findUnique
   */
  export type FeaturedMediaImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaImage to fetch.
     */
    where: FeaturedMediaImageWhereUniqueInput
  }

  /**
   * FeaturedMediaImage findUniqueOrThrow
   */
  export type FeaturedMediaImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaImage to fetch.
     */
    where: FeaturedMediaImageWhereUniqueInput
  }

  /**
   * FeaturedMediaImage findFirst
   */
  export type FeaturedMediaImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaImage to fetch.
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaImages to fetch.
     */
    orderBy?: FeaturedMediaImageOrderByWithRelationInput | FeaturedMediaImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaImages.
     */
    cursor?: FeaturedMediaImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaImages.
     */
    distinct?: FeaturedMediaImageScalarFieldEnum | FeaturedMediaImageScalarFieldEnum[]
  }

  /**
   * FeaturedMediaImage findFirstOrThrow
   */
  export type FeaturedMediaImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaImage to fetch.
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaImages to fetch.
     */
    orderBy?: FeaturedMediaImageOrderByWithRelationInput | FeaturedMediaImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedMediaImages.
     */
    cursor?: FeaturedMediaImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedMediaImages.
     */
    distinct?: FeaturedMediaImageScalarFieldEnum | FeaturedMediaImageScalarFieldEnum[]
  }

  /**
   * FeaturedMediaImage findMany
   */
  export type FeaturedMediaImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedMediaImages to fetch.
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedMediaImages to fetch.
     */
    orderBy?: FeaturedMediaImageOrderByWithRelationInput | FeaturedMediaImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedMediaImages.
     */
    cursor?: FeaturedMediaImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedMediaImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedMediaImages.
     */
    skip?: number
    distinct?: FeaturedMediaImageScalarFieldEnum | FeaturedMediaImageScalarFieldEnum[]
  }

  /**
   * FeaturedMediaImage create
   */
  export type FeaturedMediaImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedMediaImage.
     */
    data: XOR<FeaturedMediaImageCreateInput, FeaturedMediaImageUncheckedCreateInput>
  }

  /**
   * FeaturedMediaImage createMany
   */
  export type FeaturedMediaImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedMediaImages.
     */
    data: FeaturedMediaImageCreateManyInput | FeaturedMediaImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedMediaImage createManyAndReturn
   */
  export type FeaturedMediaImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedMediaImages.
     */
    data: FeaturedMediaImageCreateManyInput | FeaturedMediaImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaImage update
   */
  export type FeaturedMediaImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedMediaImage.
     */
    data: XOR<FeaturedMediaImageUpdateInput, FeaturedMediaImageUncheckedUpdateInput>
    /**
     * Choose, which FeaturedMediaImage to update.
     */
    where: FeaturedMediaImageWhereUniqueInput
  }

  /**
   * FeaturedMediaImage updateMany
   */
  export type FeaturedMediaImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedMediaImages.
     */
    data: XOR<FeaturedMediaImageUpdateManyMutationInput, FeaturedMediaImageUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaImages to update
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * Limit how many FeaturedMediaImages to update.
     */
    limit?: number
  }

  /**
   * FeaturedMediaImage updateManyAndReturn
   */
  export type FeaturedMediaImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedMediaImages.
     */
    data: XOR<FeaturedMediaImageUpdateManyMutationInput, FeaturedMediaImageUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedMediaImages to update
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * Limit how many FeaturedMediaImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedMediaImage upsert
   */
  export type FeaturedMediaImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedMediaImage to update in case it exists.
     */
    where: FeaturedMediaImageWhereUniqueInput
    /**
     * In case the FeaturedMediaImage found by the `where` argument doesn't exist, create a new FeaturedMediaImage with this data.
     */
    create: XOR<FeaturedMediaImageCreateInput, FeaturedMediaImageUncheckedCreateInput>
    /**
     * In case the FeaturedMediaImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedMediaImageUpdateInput, FeaturedMediaImageUncheckedUpdateInput>
  }

  /**
   * FeaturedMediaImage delete
   */
  export type FeaturedMediaImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    /**
     * Filter which FeaturedMediaImage to delete.
     */
    where: FeaturedMediaImageWhereUniqueInput
  }

  /**
   * FeaturedMediaImage deleteMany
   */
  export type FeaturedMediaImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedMediaImages to delete
     */
    where?: FeaturedMediaImageWhereInput
    /**
     * Limit how many FeaturedMediaImages to delete.
     */
    limit?: number
  }

  /**
   * FeaturedMediaImage without action
   */
  export type FeaturedMediaImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
  }


  /**
   * Model ProductFeaturedMedia
   */

  export type AggregateProductFeaturedMedia = {
    _count: ProductFeaturedMediaCountAggregateOutputType | null
    _min: ProductFeaturedMediaMinAggregateOutputType | null
    _max: ProductFeaturedMediaMaxAggregateOutputType | null
  }

  export type ProductFeaturedMediaMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    alt: string | null
    mediaContentType: $Enums.MediaContentType | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    featuredMediaVideoId: string | null
    featuredMediaExternalVideoId: string | null
    featuredMediaImageId: string | null
  }

  export type ProductFeaturedMediaMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    alt: string | null
    mediaContentType: $Enums.MediaContentType | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    featuredMediaVideoId: string | null
    featuredMediaExternalVideoId: string | null
    featuredMediaImageId: string | null
  }

  export type ProductFeaturedMediaCountAggregateOutputType = {
    id: number
    shopifyId: number
    alt: number
    mediaContentType: number
    productId: number
    createdAt: number
    updatedAt: number
    featuredMediaVideoId: number
    featuredMediaExternalVideoId: number
    featuredMediaImageId: number
    _all: number
  }


  export type ProductFeaturedMediaMinAggregateInputType = {
    id?: true
    shopifyId?: true
    alt?: true
    mediaContentType?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    featuredMediaVideoId?: true
    featuredMediaExternalVideoId?: true
    featuredMediaImageId?: true
  }

  export type ProductFeaturedMediaMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    alt?: true
    mediaContentType?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    featuredMediaVideoId?: true
    featuredMediaExternalVideoId?: true
    featuredMediaImageId?: true
  }

  export type ProductFeaturedMediaCountAggregateInputType = {
    id?: true
    shopifyId?: true
    alt?: true
    mediaContentType?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    featuredMediaVideoId?: true
    featuredMediaExternalVideoId?: true
    featuredMediaImageId?: true
    _all?: true
  }

  export type ProductFeaturedMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFeaturedMedia to aggregate.
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFeaturedMedias to fetch.
     */
    orderBy?: ProductFeaturedMediaOrderByWithRelationInput | ProductFeaturedMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductFeaturedMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFeaturedMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFeaturedMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFeaturedMedias
    **/
    _count?: true | ProductFeaturedMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFeaturedMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFeaturedMediaMaxAggregateInputType
  }

  export type GetProductFeaturedMediaAggregateType<T extends ProductFeaturedMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFeaturedMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFeaturedMedia[P]>
      : GetScalarType<T[P], AggregateProductFeaturedMedia[P]>
  }




  export type ProductFeaturedMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductFeaturedMediaWhereInput
    orderBy?: ProductFeaturedMediaOrderByWithAggregationInput | ProductFeaturedMediaOrderByWithAggregationInput[]
    by: ProductFeaturedMediaScalarFieldEnum[] | ProductFeaturedMediaScalarFieldEnum
    having?: ProductFeaturedMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFeaturedMediaCountAggregateInputType | true
    _min?: ProductFeaturedMediaMinAggregateInputType
    _max?: ProductFeaturedMediaMaxAggregateInputType
  }

  export type ProductFeaturedMediaGroupByOutputType = {
    id: string
    shopifyId: string
    alt: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt: Date
    updatedAt: Date
    featuredMediaVideoId: string | null
    featuredMediaExternalVideoId: string | null
    featuredMediaImageId: string | null
    _count: ProductFeaturedMediaCountAggregateOutputType | null
    _min: ProductFeaturedMediaMinAggregateOutputType | null
    _max: ProductFeaturedMediaMaxAggregateOutputType | null
  }

  type GetProductFeaturedMediaGroupByPayload<T extends ProductFeaturedMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductFeaturedMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFeaturedMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFeaturedMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFeaturedMediaGroupByOutputType[P]>
        }
      >
    >


  export type ProductFeaturedMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    alt?: boolean
    mediaContentType?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featuredMediaVideoId?: boolean
    featuredMediaExternalVideoId?: boolean
    featuredMediaImageId?: boolean
    featuredMediaVideo?: boolean | ProductFeaturedMedia$featuredMediaVideoArgs<ExtArgs>
    featuredMediaExternalVideo?: boolean | ProductFeaturedMedia$featuredMediaExternalVideoArgs<ExtArgs>
    featuredMediaImage?: boolean | ProductFeaturedMedia$featuredMediaImageArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFeaturedMedia"]>

  export type ProductFeaturedMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    alt?: boolean
    mediaContentType?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featuredMediaVideoId?: boolean
    featuredMediaExternalVideoId?: boolean
    featuredMediaImageId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFeaturedMedia"]>

  export type ProductFeaturedMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    alt?: boolean
    mediaContentType?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featuredMediaVideoId?: boolean
    featuredMediaExternalVideoId?: boolean
    featuredMediaImageId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFeaturedMedia"]>

  export type ProductFeaturedMediaSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    alt?: boolean
    mediaContentType?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featuredMediaVideoId?: boolean
    featuredMediaExternalVideoId?: boolean
    featuredMediaImageId?: boolean
  }

  export type ProductFeaturedMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "alt" | "mediaContentType" | "productId" | "createdAt" | "updatedAt" | "featuredMediaVideoId" | "featuredMediaExternalVideoId" | "featuredMediaImageId", ExtArgs["result"]["productFeaturedMedia"]>
  export type ProductFeaturedMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featuredMediaVideo?: boolean | ProductFeaturedMedia$featuredMediaVideoArgs<ExtArgs>
    featuredMediaExternalVideo?: boolean | ProductFeaturedMedia$featuredMediaExternalVideoArgs<ExtArgs>
    featuredMediaImage?: boolean | ProductFeaturedMedia$featuredMediaImageArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductFeaturedMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductFeaturedMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductFeaturedMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductFeaturedMedia"
    objects: {
      featuredMediaVideo: Prisma.$FeaturedMediaVideoPayload<ExtArgs> | null
      featuredMediaExternalVideo: Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs> | null
      featuredMediaImage: Prisma.$FeaturedMediaImagePayload<ExtArgs> | null
      Product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      alt: string | null
      mediaContentType: $Enums.MediaContentType
      productId: string
      createdAt: Date
      updatedAt: Date
      featuredMediaVideoId: string | null
      featuredMediaExternalVideoId: string | null
      featuredMediaImageId: string | null
    }, ExtArgs["result"]["productFeaturedMedia"]>
    composites: {}
  }

  type ProductFeaturedMediaGetPayload<S extends boolean | null | undefined | ProductFeaturedMediaDefaultArgs> = $Result.GetResult<Prisma.$ProductFeaturedMediaPayload, S>

  type ProductFeaturedMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFeaturedMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductFeaturedMediaCountAggregateInputType | true
    }

  export interface ProductFeaturedMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductFeaturedMedia'], meta: { name: 'ProductFeaturedMedia' } }
    /**
     * Find zero or one ProductFeaturedMedia that matches the filter.
     * @param {ProductFeaturedMediaFindUniqueArgs} args - Arguments to find a ProductFeaturedMedia
     * @example
     * // Get one ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFeaturedMediaFindUniqueArgs>(args: SelectSubset<T, ProductFeaturedMediaFindUniqueArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductFeaturedMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFeaturedMediaFindUniqueOrThrowArgs} args - Arguments to find a ProductFeaturedMedia
     * @example
     * // Get one ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFeaturedMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFeaturedMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFeaturedMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaFindFirstArgs} args - Arguments to find a ProductFeaturedMedia
     * @example
     * // Get one ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFeaturedMediaFindFirstArgs>(args?: SelectSubset<T, ProductFeaturedMediaFindFirstArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFeaturedMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaFindFirstOrThrowArgs} args - Arguments to find a ProductFeaturedMedia
     * @example
     * // Get one ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFeaturedMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFeaturedMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductFeaturedMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFeaturedMedias
     * const productFeaturedMedias = await prisma.productFeaturedMedia.findMany()
     * 
     * // Get first 10 ProductFeaturedMedias
     * const productFeaturedMedias = await prisma.productFeaturedMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFeaturedMediaWithIdOnly = await prisma.productFeaturedMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFeaturedMediaFindManyArgs>(args?: SelectSubset<T, ProductFeaturedMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductFeaturedMedia.
     * @param {ProductFeaturedMediaCreateArgs} args - Arguments to create a ProductFeaturedMedia.
     * @example
     * // Create one ProductFeaturedMedia
     * const ProductFeaturedMedia = await prisma.productFeaturedMedia.create({
     *   data: {
     *     // ... data to create a ProductFeaturedMedia
     *   }
     * })
     * 
     */
    create<T extends ProductFeaturedMediaCreateArgs>(args: SelectSubset<T, ProductFeaturedMediaCreateArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductFeaturedMedias.
     * @param {ProductFeaturedMediaCreateManyArgs} args - Arguments to create many ProductFeaturedMedias.
     * @example
     * // Create many ProductFeaturedMedias
     * const productFeaturedMedia = await prisma.productFeaturedMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductFeaturedMediaCreateManyArgs>(args?: SelectSubset<T, ProductFeaturedMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductFeaturedMedias and returns the data saved in the database.
     * @param {ProductFeaturedMediaCreateManyAndReturnArgs} args - Arguments to create many ProductFeaturedMedias.
     * @example
     * // Create many ProductFeaturedMedias
     * const productFeaturedMedia = await prisma.productFeaturedMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductFeaturedMedias and only return the `id`
     * const productFeaturedMediaWithIdOnly = await prisma.productFeaturedMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductFeaturedMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductFeaturedMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductFeaturedMedia.
     * @param {ProductFeaturedMediaDeleteArgs} args - Arguments to delete one ProductFeaturedMedia.
     * @example
     * // Delete one ProductFeaturedMedia
     * const ProductFeaturedMedia = await prisma.productFeaturedMedia.delete({
     *   where: {
     *     // ... filter to delete one ProductFeaturedMedia
     *   }
     * })
     * 
     */
    delete<T extends ProductFeaturedMediaDeleteArgs>(args: SelectSubset<T, ProductFeaturedMediaDeleteArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductFeaturedMedia.
     * @param {ProductFeaturedMediaUpdateArgs} args - Arguments to update one ProductFeaturedMedia.
     * @example
     * // Update one ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductFeaturedMediaUpdateArgs>(args: SelectSubset<T, ProductFeaturedMediaUpdateArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductFeaturedMedias.
     * @param {ProductFeaturedMediaDeleteManyArgs} args - Arguments to filter ProductFeaturedMedias to delete.
     * @example
     * // Delete a few ProductFeaturedMedias
     * const { count } = await prisma.productFeaturedMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductFeaturedMediaDeleteManyArgs>(args?: SelectSubset<T, ProductFeaturedMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFeaturedMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFeaturedMedias
     * const productFeaturedMedia = await prisma.productFeaturedMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductFeaturedMediaUpdateManyArgs>(args: SelectSubset<T, ProductFeaturedMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFeaturedMedias and returns the data updated in the database.
     * @param {ProductFeaturedMediaUpdateManyAndReturnArgs} args - Arguments to update many ProductFeaturedMedias.
     * @example
     * // Update many ProductFeaturedMedias
     * const productFeaturedMedia = await prisma.productFeaturedMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductFeaturedMedias and only return the `id`
     * const productFeaturedMediaWithIdOnly = await prisma.productFeaturedMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductFeaturedMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductFeaturedMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductFeaturedMedia.
     * @param {ProductFeaturedMediaUpsertArgs} args - Arguments to update or create a ProductFeaturedMedia.
     * @example
     * // Update or create a ProductFeaturedMedia
     * const productFeaturedMedia = await prisma.productFeaturedMedia.upsert({
     *   create: {
     *     // ... data to create a ProductFeaturedMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFeaturedMedia we want to update
     *   }
     * })
     */
    upsert<T extends ProductFeaturedMediaUpsertArgs>(args: SelectSubset<T, ProductFeaturedMediaUpsertArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductFeaturedMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaCountArgs} args - Arguments to filter ProductFeaturedMedias to count.
     * @example
     * // Count the number of ProductFeaturedMedias
     * const count = await prisma.productFeaturedMedia.count({
     *   where: {
     *     // ... the filter for the ProductFeaturedMedias we want to count
     *   }
     * })
    **/
    count<T extends ProductFeaturedMediaCountArgs>(
      args?: Subset<T, ProductFeaturedMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFeaturedMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFeaturedMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFeaturedMediaAggregateArgs>(args: Subset<T, ProductFeaturedMediaAggregateArgs>): Prisma.PrismaPromise<GetProductFeaturedMediaAggregateType<T>>

    /**
     * Group by ProductFeaturedMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFeaturedMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFeaturedMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFeaturedMediaGroupByArgs['orderBy'] }
        : { orderBy?: ProductFeaturedMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFeaturedMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFeaturedMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductFeaturedMedia model
   */
  readonly fields: ProductFeaturedMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFeaturedMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductFeaturedMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    featuredMediaVideo<T extends ProductFeaturedMedia$featuredMediaVideoArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMedia$featuredMediaVideoArgs<ExtArgs>>): Prisma__FeaturedMediaVideoClient<$Result.GetResult<Prisma.$FeaturedMediaVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    featuredMediaExternalVideo<T extends ProductFeaturedMedia$featuredMediaExternalVideoArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMedia$featuredMediaExternalVideoArgs<ExtArgs>>): Prisma__FeaturedMediaExternalVideoClient<$Result.GetResult<Prisma.$FeaturedMediaExternalVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    featuredMediaImage<T extends ProductFeaturedMedia$featuredMediaImageArgs<ExtArgs> = {}>(args?: Subset<T, ProductFeaturedMedia$featuredMediaImageArgs<ExtArgs>>): Prisma__FeaturedMediaImageClient<$Result.GetResult<Prisma.$FeaturedMediaImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductFeaturedMedia model
   */ 
  interface ProductFeaturedMediaFieldRefs {
    readonly id: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly shopifyId: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly alt: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly mediaContentType: FieldRef<"ProductFeaturedMedia", 'MediaContentType'>
    readonly productId: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly createdAt: FieldRef<"ProductFeaturedMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductFeaturedMedia", 'DateTime'>
    readonly featuredMediaVideoId: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly featuredMediaExternalVideoId: FieldRef<"ProductFeaturedMedia", 'String'>
    readonly featuredMediaImageId: FieldRef<"ProductFeaturedMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductFeaturedMedia findUnique
   */
  export type ProductFeaturedMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductFeaturedMedia to fetch.
     */
    where: ProductFeaturedMediaWhereUniqueInput
  }

  /**
   * ProductFeaturedMedia findUniqueOrThrow
   */
  export type ProductFeaturedMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductFeaturedMedia to fetch.
     */
    where: ProductFeaturedMediaWhereUniqueInput
  }

  /**
   * ProductFeaturedMedia findFirst
   */
  export type ProductFeaturedMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductFeaturedMedia to fetch.
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFeaturedMedias to fetch.
     */
    orderBy?: ProductFeaturedMediaOrderByWithRelationInput | ProductFeaturedMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFeaturedMedias.
     */
    cursor?: ProductFeaturedMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFeaturedMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFeaturedMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFeaturedMedias.
     */
    distinct?: ProductFeaturedMediaScalarFieldEnum | ProductFeaturedMediaScalarFieldEnum[]
  }

  /**
   * ProductFeaturedMedia findFirstOrThrow
   */
  export type ProductFeaturedMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductFeaturedMedia to fetch.
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFeaturedMedias to fetch.
     */
    orderBy?: ProductFeaturedMediaOrderByWithRelationInput | ProductFeaturedMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFeaturedMedias.
     */
    cursor?: ProductFeaturedMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFeaturedMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFeaturedMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFeaturedMedias.
     */
    distinct?: ProductFeaturedMediaScalarFieldEnum | ProductFeaturedMediaScalarFieldEnum[]
  }

  /**
   * ProductFeaturedMedia findMany
   */
  export type ProductFeaturedMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductFeaturedMedias to fetch.
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFeaturedMedias to fetch.
     */
    orderBy?: ProductFeaturedMediaOrderByWithRelationInput | ProductFeaturedMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFeaturedMedias.
     */
    cursor?: ProductFeaturedMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFeaturedMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFeaturedMedias.
     */
    skip?: number
    distinct?: ProductFeaturedMediaScalarFieldEnum | ProductFeaturedMediaScalarFieldEnum[]
  }

  /**
   * ProductFeaturedMedia create
   */
  export type ProductFeaturedMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductFeaturedMedia.
     */
    data: XOR<ProductFeaturedMediaCreateInput, ProductFeaturedMediaUncheckedCreateInput>
  }

  /**
   * ProductFeaturedMedia createMany
   */
  export type ProductFeaturedMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductFeaturedMedias.
     */
    data: ProductFeaturedMediaCreateManyInput | ProductFeaturedMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductFeaturedMedia createManyAndReturn
   */
  export type ProductFeaturedMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * The data used to create many ProductFeaturedMedias.
     */
    data: ProductFeaturedMediaCreateManyInput | ProductFeaturedMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductFeaturedMedia update
   */
  export type ProductFeaturedMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductFeaturedMedia.
     */
    data: XOR<ProductFeaturedMediaUpdateInput, ProductFeaturedMediaUncheckedUpdateInput>
    /**
     * Choose, which ProductFeaturedMedia to update.
     */
    where: ProductFeaturedMediaWhereUniqueInput
  }

  /**
   * ProductFeaturedMedia updateMany
   */
  export type ProductFeaturedMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductFeaturedMedias.
     */
    data: XOR<ProductFeaturedMediaUpdateManyMutationInput, ProductFeaturedMediaUncheckedUpdateManyInput>
    /**
     * Filter which ProductFeaturedMedias to update
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * Limit how many ProductFeaturedMedias to update.
     */
    limit?: number
  }

  /**
   * ProductFeaturedMedia updateManyAndReturn
   */
  export type ProductFeaturedMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * The data used to update ProductFeaturedMedias.
     */
    data: XOR<ProductFeaturedMediaUpdateManyMutationInput, ProductFeaturedMediaUncheckedUpdateManyInput>
    /**
     * Filter which ProductFeaturedMedias to update
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * Limit how many ProductFeaturedMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductFeaturedMedia upsert
   */
  export type ProductFeaturedMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductFeaturedMedia to update in case it exists.
     */
    where: ProductFeaturedMediaWhereUniqueInput
    /**
     * In case the ProductFeaturedMedia found by the `where` argument doesn't exist, create a new ProductFeaturedMedia with this data.
     */
    create: XOR<ProductFeaturedMediaCreateInput, ProductFeaturedMediaUncheckedCreateInput>
    /**
     * In case the ProductFeaturedMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductFeaturedMediaUpdateInput, ProductFeaturedMediaUncheckedUpdateInput>
  }

  /**
   * ProductFeaturedMedia delete
   */
  export type ProductFeaturedMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    /**
     * Filter which ProductFeaturedMedia to delete.
     */
    where: ProductFeaturedMediaWhereUniqueInput
  }

  /**
   * ProductFeaturedMedia deleteMany
   */
  export type ProductFeaturedMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFeaturedMedias to delete
     */
    where?: ProductFeaturedMediaWhereInput
    /**
     * Limit how many ProductFeaturedMedias to delete.
     */
    limit?: number
  }

  /**
   * ProductFeaturedMedia.featuredMediaVideo
   */
  export type ProductFeaturedMedia$featuredMediaVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaVideo
     */
    select?: FeaturedMediaVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaVideo
     */
    omit?: FeaturedMediaVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaVideoInclude<ExtArgs> | null
    where?: FeaturedMediaVideoWhereInput
  }

  /**
   * ProductFeaturedMedia.featuredMediaExternalVideo
   */
  export type ProductFeaturedMedia$featuredMediaExternalVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaExternalVideo
     */
    select?: FeaturedMediaExternalVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaExternalVideo
     */
    omit?: FeaturedMediaExternalVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaExternalVideoInclude<ExtArgs> | null
    where?: FeaturedMediaExternalVideoWhereInput
  }

  /**
   * ProductFeaturedMedia.featuredMediaImage
   */
  export type ProductFeaturedMedia$featuredMediaImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedMediaImage
     */
    select?: FeaturedMediaImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedMediaImage
     */
    omit?: FeaturedMediaImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedMediaImageInclude<ExtArgs> | null
    where?: FeaturedMediaImageWhereInput
  }

  /**
   * ProductFeaturedMedia without action
   */
  export type ProductFeaturedMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
  }


  /**
   * Model ProductSEO
   */

  export type AggregateProductSEO = {
    _count: ProductSEOCountAggregateOutputType | null
    _min: ProductSEOMinAggregateOutputType | null
    _max: ProductSEOMaxAggregateOutputType | null
  }

  export type ProductSEOMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSEOMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSEOCountAggregateOutputType = {
    id: number
    title: number
    description: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductSEOMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSEOMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSEOCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductSEOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSEO to aggregate.
     */
    where?: ProductSEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSEOS to fetch.
     */
    orderBy?: ProductSEOOrderByWithRelationInput | ProductSEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSEOS
    **/
    _count?: true | ProductSEOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSEOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSEOMaxAggregateInputType
  }

  export type GetProductSEOAggregateType<T extends ProductSEOAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSEO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSEO[P]>
      : GetScalarType<T[P], AggregateProductSEO[P]>
  }




  export type ProductSEOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSEOWhereInput
    orderBy?: ProductSEOOrderByWithAggregationInput | ProductSEOOrderByWithAggregationInput[]
    by: ProductSEOScalarFieldEnum[] | ProductSEOScalarFieldEnum
    having?: ProductSEOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSEOCountAggregateInputType | true
    _min?: ProductSEOMinAggregateInputType
    _max?: ProductSEOMaxAggregateInputType
  }

  export type ProductSEOGroupByOutputType = {
    id: string
    title: string | null
    description: string | null
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductSEOCountAggregateOutputType | null
    _min: ProductSEOMinAggregateOutputType | null
    _max: ProductSEOMaxAggregateOutputType | null
  }

  type GetProductSEOGroupByPayload<T extends ProductSEOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSEOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSEOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSEOGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSEOGroupByOutputType[P]>
        }
      >
    >


  export type ProductSEOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSEO"]>

  export type ProductSEOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSEO"]>

  export type ProductSEOSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSEO"]>

  export type ProductSEOSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductSEOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["productSEO"]>
  export type ProductSEOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSEOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSEOIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductSEOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSEO"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      description: string | null
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productSEO"]>
    composites: {}
  }

  type ProductSEOGetPayload<S extends boolean | null | undefined | ProductSEODefaultArgs> = $Result.GetResult<Prisma.$ProductSEOPayload, S>

  type ProductSEOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductSEOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductSEOCountAggregateInputType | true
    }

  export interface ProductSEODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSEO'], meta: { name: 'ProductSEO' } }
    /**
     * Find zero or one ProductSEO that matches the filter.
     * @param {ProductSEOFindUniqueArgs} args - Arguments to find a ProductSEO
     * @example
     * // Get one ProductSEO
     * const productSEO = await prisma.productSEO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSEOFindUniqueArgs>(args: SelectSubset<T, ProductSEOFindUniqueArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSEO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductSEOFindUniqueOrThrowArgs} args - Arguments to find a ProductSEO
     * @example
     * // Get one ProductSEO
     * const productSEO = await prisma.productSEO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSEOFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSEOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSEO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOFindFirstArgs} args - Arguments to find a ProductSEO
     * @example
     * // Get one ProductSEO
     * const productSEO = await prisma.productSEO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSEOFindFirstArgs>(args?: SelectSubset<T, ProductSEOFindFirstArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSEO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOFindFirstOrThrowArgs} args - Arguments to find a ProductSEO
     * @example
     * // Get one ProductSEO
     * const productSEO = await prisma.productSEO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSEOFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSEOFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSEOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSEOS
     * const productSEOS = await prisma.productSEO.findMany()
     * 
     * // Get first 10 ProductSEOS
     * const productSEOS = await prisma.productSEO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSEOWithIdOnly = await prisma.productSEO.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSEOFindManyArgs>(args?: SelectSubset<T, ProductSEOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSEO.
     * @param {ProductSEOCreateArgs} args - Arguments to create a ProductSEO.
     * @example
     * // Create one ProductSEO
     * const ProductSEO = await prisma.productSEO.create({
     *   data: {
     *     // ... data to create a ProductSEO
     *   }
     * })
     * 
     */
    create<T extends ProductSEOCreateArgs>(args: SelectSubset<T, ProductSEOCreateArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSEOS.
     * @param {ProductSEOCreateManyArgs} args - Arguments to create many ProductSEOS.
     * @example
     * // Create many ProductSEOS
     * const productSEO = await prisma.productSEO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSEOCreateManyArgs>(args?: SelectSubset<T, ProductSEOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSEOS and returns the data saved in the database.
     * @param {ProductSEOCreateManyAndReturnArgs} args - Arguments to create many ProductSEOS.
     * @example
     * // Create many ProductSEOS
     * const productSEO = await prisma.productSEO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSEOS and only return the `id`
     * const productSEOWithIdOnly = await prisma.productSEO.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductSEOCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductSEOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductSEO.
     * @param {ProductSEODeleteArgs} args - Arguments to delete one ProductSEO.
     * @example
     * // Delete one ProductSEO
     * const ProductSEO = await prisma.productSEO.delete({
     *   where: {
     *     // ... filter to delete one ProductSEO
     *   }
     * })
     * 
     */
    delete<T extends ProductSEODeleteArgs>(args: SelectSubset<T, ProductSEODeleteArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSEO.
     * @param {ProductSEOUpdateArgs} args - Arguments to update one ProductSEO.
     * @example
     * // Update one ProductSEO
     * const productSEO = await prisma.productSEO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSEOUpdateArgs>(args: SelectSubset<T, ProductSEOUpdateArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSEOS.
     * @param {ProductSEODeleteManyArgs} args - Arguments to filter ProductSEOS to delete.
     * @example
     * // Delete a few ProductSEOS
     * const { count } = await prisma.productSEO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSEODeleteManyArgs>(args?: SelectSubset<T, ProductSEODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSEOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSEOS
     * const productSEO = await prisma.productSEO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSEOUpdateManyArgs>(args: SelectSubset<T, ProductSEOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSEOS and returns the data updated in the database.
     * @param {ProductSEOUpdateManyAndReturnArgs} args - Arguments to update many ProductSEOS.
     * @example
     * // Update many ProductSEOS
     * const productSEO = await prisma.productSEO.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductSEOS and only return the `id`
     * const productSEOWithIdOnly = await prisma.productSEO.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductSEOUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductSEOUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductSEO.
     * @param {ProductSEOUpsertArgs} args - Arguments to update or create a ProductSEO.
     * @example
     * // Update or create a ProductSEO
     * const productSEO = await prisma.productSEO.upsert({
     *   create: {
     *     // ... data to create a ProductSEO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSEO we want to update
     *   }
     * })
     */
    upsert<T extends ProductSEOUpsertArgs>(args: SelectSubset<T, ProductSEOUpsertArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSEOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOCountArgs} args - Arguments to filter ProductSEOS to count.
     * @example
     * // Count the number of ProductSEOS
     * const count = await prisma.productSEO.count({
     *   where: {
     *     // ... the filter for the ProductSEOS we want to count
     *   }
     * })
    **/
    count<T extends ProductSEOCountArgs>(
      args?: Subset<T, ProductSEOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSEOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSEO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSEOAggregateArgs>(args: Subset<T, ProductSEOAggregateArgs>): Prisma.PrismaPromise<GetProductSEOAggregateType<T>>

    /**
     * Group by ProductSEO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSEOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSEOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSEOGroupByArgs['orderBy'] }
        : { orderBy?: ProductSEOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSEOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSEOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSEO model
   */
  readonly fields: ProductSEOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSEO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSEOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSEO model
   */ 
  interface ProductSEOFieldRefs {
    readonly id: FieldRef<"ProductSEO", 'String'>
    readonly title: FieldRef<"ProductSEO", 'String'>
    readonly description: FieldRef<"ProductSEO", 'String'>
    readonly productId: FieldRef<"ProductSEO", 'String'>
    readonly createdAt: FieldRef<"ProductSEO", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductSEO", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductSEO findUnique
   */
  export type ProductSEOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter, which ProductSEO to fetch.
     */
    where: ProductSEOWhereUniqueInput
  }

  /**
   * ProductSEO findUniqueOrThrow
   */
  export type ProductSEOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter, which ProductSEO to fetch.
     */
    where: ProductSEOWhereUniqueInput
  }

  /**
   * ProductSEO findFirst
   */
  export type ProductSEOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter, which ProductSEO to fetch.
     */
    where?: ProductSEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSEOS to fetch.
     */
    orderBy?: ProductSEOOrderByWithRelationInput | ProductSEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSEOS.
     */
    cursor?: ProductSEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSEOS.
     */
    distinct?: ProductSEOScalarFieldEnum | ProductSEOScalarFieldEnum[]
  }

  /**
   * ProductSEO findFirstOrThrow
   */
  export type ProductSEOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter, which ProductSEO to fetch.
     */
    where?: ProductSEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSEOS to fetch.
     */
    orderBy?: ProductSEOOrderByWithRelationInput | ProductSEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSEOS.
     */
    cursor?: ProductSEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSEOS.
     */
    distinct?: ProductSEOScalarFieldEnum | ProductSEOScalarFieldEnum[]
  }

  /**
   * ProductSEO findMany
   */
  export type ProductSEOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter, which ProductSEOS to fetch.
     */
    where?: ProductSEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSEOS to fetch.
     */
    orderBy?: ProductSEOOrderByWithRelationInput | ProductSEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSEOS.
     */
    cursor?: ProductSEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSEOS.
     */
    skip?: number
    distinct?: ProductSEOScalarFieldEnum | ProductSEOScalarFieldEnum[]
  }

  /**
   * ProductSEO create
   */
  export type ProductSEOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSEO.
     */
    data: XOR<ProductSEOCreateInput, ProductSEOUncheckedCreateInput>
  }

  /**
   * ProductSEO createMany
   */
  export type ProductSEOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSEOS.
     */
    data: ProductSEOCreateManyInput | ProductSEOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSEO createManyAndReturn
   */
  export type ProductSEOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * The data used to create many ProductSEOS.
     */
    data: ProductSEOCreateManyInput | ProductSEOCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSEO update
   */
  export type ProductSEOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSEO.
     */
    data: XOR<ProductSEOUpdateInput, ProductSEOUncheckedUpdateInput>
    /**
     * Choose, which ProductSEO to update.
     */
    where: ProductSEOWhereUniqueInput
  }

  /**
   * ProductSEO updateMany
   */
  export type ProductSEOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSEOS.
     */
    data: XOR<ProductSEOUpdateManyMutationInput, ProductSEOUncheckedUpdateManyInput>
    /**
     * Filter which ProductSEOS to update
     */
    where?: ProductSEOWhereInput
    /**
     * Limit how many ProductSEOS to update.
     */
    limit?: number
  }

  /**
   * ProductSEO updateManyAndReturn
   */
  export type ProductSEOUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * The data used to update ProductSEOS.
     */
    data: XOR<ProductSEOUpdateManyMutationInput, ProductSEOUncheckedUpdateManyInput>
    /**
     * Filter which ProductSEOS to update
     */
    where?: ProductSEOWhereInput
    /**
     * Limit how many ProductSEOS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSEO upsert
   */
  export type ProductSEOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSEO to update in case it exists.
     */
    where: ProductSEOWhereUniqueInput
    /**
     * In case the ProductSEO found by the `where` argument doesn't exist, create a new ProductSEO with this data.
     */
    create: XOR<ProductSEOCreateInput, ProductSEOUncheckedCreateInput>
    /**
     * In case the ProductSEO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSEOUpdateInput, ProductSEOUncheckedUpdateInput>
  }

  /**
   * ProductSEO delete
   */
  export type ProductSEODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    /**
     * Filter which ProductSEO to delete.
     */
    where: ProductSEOWhereUniqueInput
  }

  /**
   * ProductSEO deleteMany
   */
  export type ProductSEODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSEOS to delete
     */
    where?: ProductSEOWhereInput
    /**
     * Limit how many ProductSEOS to delete.
     */
    limit?: number
  }

  /**
   * ProductSEO without action
   */
  export type ProductSEODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariantProduct
   */

  export type AggregateProductVariantProduct = {
    _count: ProductVariantProductCountAggregateOutputType | null
    _min: ProductVariantProductMinAggregateOutputType | null
    _max: ProductVariantProductMaxAggregateOutputType | null
  }

  export type ProductVariantProductMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    handle: string | null
    onlineStoreUrl: string | null
    productVariantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantProductMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    handle: string | null
    onlineStoreUrl: string | null
    productVariantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantProductCountAggregateOutputType = {
    id: number
    shopifyId: number
    handle: number
    onlineStoreUrl: number
    productVariantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantProductMinAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    onlineStoreUrl?: true
    productVariantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantProductMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    onlineStoreUrl?: true
    productVariantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantProductCountAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    onlineStoreUrl?: true
    productVariantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariantProduct to aggregate.
     */
    where?: ProductVariantProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantProducts to fetch.
     */
    orderBy?: ProductVariantProductOrderByWithRelationInput | ProductVariantProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariantProducts
    **/
    _count?: true | ProductVariantProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantProductMaxAggregateInputType
  }

  export type GetProductVariantProductAggregateType<T extends ProductVariantProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariantProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariantProduct[P]>
      : GetScalarType<T[P], AggregateProductVariantProduct[P]>
  }




  export type ProductVariantProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantProductWhereInput
    orderBy?: ProductVariantProductOrderByWithAggregationInput | ProductVariantProductOrderByWithAggregationInput[]
    by: ProductVariantProductScalarFieldEnum[] | ProductVariantProductScalarFieldEnum
    having?: ProductVariantProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantProductCountAggregateInputType | true
    _min?: ProductVariantProductMinAggregateInputType
    _max?: ProductVariantProductMaxAggregateInputType
  }

  export type ProductVariantProductGroupByOutputType = {
    id: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    productVariantId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantProductCountAggregateOutputType | null
    _min: ProductVariantProductMinAggregateOutputType | null
    _max: ProductVariantProductMaxAggregateOutputType | null
  }

  type GetProductVariantProductGroupByPayload<T extends ProductVariantProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    onlineStoreUrl?: boolean
    productVariantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantProduct"]>

  export type ProductVariantProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    onlineStoreUrl?: boolean
    productVariantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantProduct"]>

  export type ProductVariantProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    onlineStoreUrl?: boolean
    productVariantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantProduct"]>

  export type ProductVariantProductSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    onlineStoreUrl?: boolean
    productVariantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "handle" | "onlineStoreUrl" | "productVariantId" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariantProduct"]>
  export type ProductVariantProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type ProductVariantProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type ProductVariantProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $ProductVariantProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariantProduct"
    objects: {
      productVariant: Prisma.$ProductVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      handle: string
      onlineStoreUrl: string
      productVariantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariantProduct"]>
    composites: {}
  }

  type ProductVariantProductGetPayload<S extends boolean | null | undefined | ProductVariantProductDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantProductPayload, S>

  type ProductVariantProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantProductCountAggregateInputType | true
    }

  export interface ProductVariantProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariantProduct'], meta: { name: 'ProductVariantProduct' } }
    /**
     * Find zero or one ProductVariantProduct that matches the filter.
     * @param {ProductVariantProductFindUniqueArgs} args - Arguments to find a ProductVariantProduct
     * @example
     * // Get one ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantProductFindUniqueArgs>(args: SelectSubset<T, ProductVariantProductFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariantProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantProductFindUniqueOrThrowArgs} args - Arguments to find a ProductVariantProduct
     * @example
     * // Get one ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariantProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductFindFirstArgs} args - Arguments to find a ProductVariantProduct
     * @example
     * // Get one ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantProductFindFirstArgs>(args?: SelectSubset<T, ProductVariantProductFindFirstArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariantProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductFindFirstOrThrowArgs} args - Arguments to find a ProductVariantProduct
     * @example
     * // Get one ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariantProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariantProducts
     * const productVariantProducts = await prisma.productVariantProduct.findMany()
     * 
     * // Get first 10 ProductVariantProducts
     * const productVariantProducts = await prisma.productVariantProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantProductWithIdOnly = await prisma.productVariantProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantProductFindManyArgs>(args?: SelectSubset<T, ProductVariantProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariantProduct.
     * @param {ProductVariantProductCreateArgs} args - Arguments to create a ProductVariantProduct.
     * @example
     * // Create one ProductVariantProduct
     * const ProductVariantProduct = await prisma.productVariantProduct.create({
     *   data: {
     *     // ... data to create a ProductVariantProduct
     *   }
     * })
     * 
     */
    create<T extends ProductVariantProductCreateArgs>(args: SelectSubset<T, ProductVariantProductCreateArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariantProducts.
     * @param {ProductVariantProductCreateManyArgs} args - Arguments to create many ProductVariantProducts.
     * @example
     * // Create many ProductVariantProducts
     * const productVariantProduct = await prisma.productVariantProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantProductCreateManyArgs>(args?: SelectSubset<T, ProductVariantProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariantProducts and returns the data saved in the database.
     * @param {ProductVariantProductCreateManyAndReturnArgs} args - Arguments to create many ProductVariantProducts.
     * @example
     * // Create many ProductVariantProducts
     * const productVariantProduct = await prisma.productVariantProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariantProducts and only return the `id`
     * const productVariantProductWithIdOnly = await prisma.productVariantProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariantProduct.
     * @param {ProductVariantProductDeleteArgs} args - Arguments to delete one ProductVariantProduct.
     * @example
     * // Delete one ProductVariantProduct
     * const ProductVariantProduct = await prisma.productVariantProduct.delete({
     *   where: {
     *     // ... filter to delete one ProductVariantProduct
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantProductDeleteArgs>(args: SelectSubset<T, ProductVariantProductDeleteArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariantProduct.
     * @param {ProductVariantProductUpdateArgs} args - Arguments to update one ProductVariantProduct.
     * @example
     * // Update one ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantProductUpdateArgs>(args: SelectSubset<T, ProductVariantProductUpdateArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariantProducts.
     * @param {ProductVariantProductDeleteManyArgs} args - Arguments to filter ProductVariantProducts to delete.
     * @example
     * // Delete a few ProductVariantProducts
     * const { count } = await prisma.productVariantProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantProductDeleteManyArgs>(args?: SelectSubset<T, ProductVariantProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariantProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariantProducts
     * const productVariantProduct = await prisma.productVariantProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantProductUpdateManyArgs>(args: SelectSubset<T, ProductVariantProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariantProducts and returns the data updated in the database.
     * @param {ProductVariantProductUpdateManyAndReturnArgs} args - Arguments to update many ProductVariantProducts.
     * @example
     * // Update many ProductVariantProducts
     * const productVariantProduct = await prisma.productVariantProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariantProducts and only return the `id`
     * const productVariantProductWithIdOnly = await prisma.productVariantProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariantProduct.
     * @param {ProductVariantProductUpsertArgs} args - Arguments to update or create a ProductVariantProduct.
     * @example
     * // Update or create a ProductVariantProduct
     * const productVariantProduct = await prisma.productVariantProduct.upsert({
     *   create: {
     *     // ... data to create a ProductVariantProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariantProduct we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantProductUpsertArgs>(args: SelectSubset<T, ProductVariantProductUpsertArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariantProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductCountArgs} args - Arguments to filter ProductVariantProducts to count.
     * @example
     * // Count the number of ProductVariantProducts
     * const count = await prisma.productVariantProduct.count({
     *   where: {
     *     // ... the filter for the ProductVariantProducts we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantProductCountArgs>(
      args?: Subset<T, ProductVariantProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariantProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantProductAggregateArgs>(args: Subset<T, ProductVariantProductAggregateArgs>): Prisma.PrismaPromise<GetProductVariantProductAggregateType<T>>

    /**
     * Group by ProductVariantProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariantProduct model
   */
  readonly fields: ProductVariantProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariantProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productVariant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariantProduct model
   */ 
  interface ProductVariantProductFieldRefs {
    readonly id: FieldRef<"ProductVariantProduct", 'String'>
    readonly shopifyId: FieldRef<"ProductVariantProduct", 'String'>
    readonly handle: FieldRef<"ProductVariantProduct", 'String'>
    readonly onlineStoreUrl: FieldRef<"ProductVariantProduct", 'String'>
    readonly productVariantId: FieldRef<"ProductVariantProduct", 'String'>
    readonly createdAt: FieldRef<"ProductVariantProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariantProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariantProduct findUnique
   */
  export type ProductVariantProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantProduct to fetch.
     */
    where: ProductVariantProductWhereUniqueInput
  }

  /**
   * ProductVariantProduct findUniqueOrThrow
   */
  export type ProductVariantProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantProduct to fetch.
     */
    where: ProductVariantProductWhereUniqueInput
  }

  /**
   * ProductVariantProduct findFirst
   */
  export type ProductVariantProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantProduct to fetch.
     */
    where?: ProductVariantProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantProducts to fetch.
     */
    orderBy?: ProductVariantProductOrderByWithRelationInput | ProductVariantProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariantProducts.
     */
    cursor?: ProductVariantProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariantProducts.
     */
    distinct?: ProductVariantProductScalarFieldEnum | ProductVariantProductScalarFieldEnum[]
  }

  /**
   * ProductVariantProduct findFirstOrThrow
   */
  export type ProductVariantProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantProduct to fetch.
     */
    where?: ProductVariantProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantProducts to fetch.
     */
    orderBy?: ProductVariantProductOrderByWithRelationInput | ProductVariantProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariantProducts.
     */
    cursor?: ProductVariantProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariantProducts.
     */
    distinct?: ProductVariantProductScalarFieldEnum | ProductVariantProductScalarFieldEnum[]
  }

  /**
   * ProductVariantProduct findMany
   */
  export type ProductVariantProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantProducts to fetch.
     */
    where?: ProductVariantProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantProducts to fetch.
     */
    orderBy?: ProductVariantProductOrderByWithRelationInput | ProductVariantProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariantProducts.
     */
    cursor?: ProductVariantProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantProducts.
     */
    skip?: number
    distinct?: ProductVariantProductScalarFieldEnum | ProductVariantProductScalarFieldEnum[]
  }

  /**
   * ProductVariantProduct create
   */
  export type ProductVariantProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariantProduct.
     */
    data: XOR<ProductVariantProductCreateInput, ProductVariantProductUncheckedCreateInput>
  }

  /**
   * ProductVariantProduct createMany
   */
  export type ProductVariantProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariantProducts.
     */
    data: ProductVariantProductCreateManyInput | ProductVariantProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariantProduct createManyAndReturn
   */
  export type ProductVariantProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariantProducts.
     */
    data: ProductVariantProductCreateManyInput | ProductVariantProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariantProduct update
   */
  export type ProductVariantProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariantProduct.
     */
    data: XOR<ProductVariantProductUpdateInput, ProductVariantProductUncheckedUpdateInput>
    /**
     * Choose, which ProductVariantProduct to update.
     */
    where: ProductVariantProductWhereUniqueInput
  }

  /**
   * ProductVariantProduct updateMany
   */
  export type ProductVariantProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariantProducts.
     */
    data: XOR<ProductVariantProductUpdateManyMutationInput, ProductVariantProductUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariantProducts to update
     */
    where?: ProductVariantProductWhereInput
    /**
     * Limit how many ProductVariantProducts to update.
     */
    limit?: number
  }

  /**
   * ProductVariantProduct updateManyAndReturn
   */
  export type ProductVariantProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariantProducts.
     */
    data: XOR<ProductVariantProductUpdateManyMutationInput, ProductVariantProductUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariantProducts to update
     */
    where?: ProductVariantProductWhereInput
    /**
     * Limit how many ProductVariantProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariantProduct upsert
   */
  export type ProductVariantProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariantProduct to update in case it exists.
     */
    where: ProductVariantProductWhereUniqueInput
    /**
     * In case the ProductVariantProduct found by the `where` argument doesn't exist, create a new ProductVariantProduct with this data.
     */
    create: XOR<ProductVariantProductCreateInput, ProductVariantProductUncheckedCreateInput>
    /**
     * In case the ProductVariantProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantProductUpdateInput, ProductVariantProductUncheckedUpdateInput>
  }

  /**
   * ProductVariantProduct delete
   */
  export type ProductVariantProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    /**
     * Filter which ProductVariantProduct to delete.
     */
    where: ProductVariantProductWhereUniqueInput
  }

  /**
   * ProductVariantProduct deleteMany
   */
  export type ProductVariantProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariantProducts to delete
     */
    where?: ProductVariantProductWhereInput
    /**
     * Limit how many ProductVariantProducts to delete.
     */
    limit?: number
  }

  /**
   * ProductVariantProduct without action
   */
  export type ProductVariantProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    title: string | null
    productId: string | null
    productVariantProductId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    title: string | null
    productId: string | null
    productVariantProductId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    shopifyId: number
    title: number
    productId: number
    productVariantProductId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantMinAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    productId?: true
    productVariantProductId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    productId?: true
    productVariantProductId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    productId?: true
    productVariantProductId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    shopifyId: string
    title: string | null
    productId: string | null
    productVariantProductId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    productId?: boolean
    productVariantProductId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productVariantProduct?: boolean | ProductVariant$productVariantProductArgs<ExtArgs>
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    productId?: boolean
    productVariantProductId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    productId?: boolean
    productVariantProductId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    productId?: boolean
    productVariantProductId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "title" | "productId" | "productVariantProductId" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productVariantProduct?: boolean | ProductVariant$productVariantProductArgs<ExtArgs>
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }
  export type ProductVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductVariant$productArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      productVariantProduct: Prisma.$ProductVariantProductPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      title: string | null
      productId: string | null
      productVariantProductId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productVariantProduct<T extends ProductVariant$productVariantProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$productVariantProductArgs<ExtArgs>>): Prisma__ProductVariantProductClient<$Result.GetResult<Prisma.$ProductVariantProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductVariant$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */ 
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly shopifyId: FieldRef<"ProductVariant", 'String'>
    readonly title: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly productVariantProductId: FieldRef<"ProductVariant", 'String'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant.productVariantProduct
   */
  export type ProductVariant$productVariantProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantProduct
     */
    select?: ProductVariantProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantProduct
     */
    omit?: ProductVariantProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantProductInclude<ExtArgs> | null
    where?: ProductVariantProductWhereInput
  }

  /**
   * ProductVariant.product
   */
  export type ProductVariant$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    handle: string | null
    description: string | null
    title: string | null
    onlineStoreUrl: string | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productSEOId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    handle: string | null
    description: string | null
    title: string | null
    onlineStoreUrl: string | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productSEOId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    shopifyId: number
    handle: number
    description: number
    title: number
    tags: number
    onlineStoreUrl: number
    shopId: number
    createdAt: number
    updatedAt: number
    productSEOId: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    description?: true
    title?: true
    onlineStoreUrl?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    productSEOId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    description?: true
    title?: true
    onlineStoreUrl?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    productSEOId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    shopifyId?: true
    handle?: true
    description?: true
    title?: true
    tags?: true
    onlineStoreUrl?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    productSEOId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    shopifyId: string
    handle: string
    description: string | null
    title: string | null
    tags: string[]
    onlineStoreUrl: string
    shopId: string | null
    createdAt: Date
    updatedAt: Date
    productSEOId: string | null
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    description?: boolean
    title?: boolean
    tags?: boolean
    onlineStoreUrl?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productSEOId?: boolean
    shop?: boolean | Product$shopArgs<ExtArgs>
    ProductSEO?: boolean | Product$ProductSEOArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    featuredMedia?: boolean | Product$featuredMediaArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    description?: boolean
    title?: boolean
    tags?: boolean
    onlineStoreUrl?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productSEOId?: boolean
    shop?: boolean | Product$shopArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    description?: boolean
    title?: boolean
    tags?: boolean
    onlineStoreUrl?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productSEOId?: boolean
    shop?: boolean | Product$shopArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    handle?: boolean
    description?: boolean
    title?: boolean
    tags?: boolean
    onlineStoreUrl?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productSEOId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "handle" | "description" | "title" | "tags" | "onlineStoreUrl" | "shopId" | "createdAt" | "updatedAt" | "productSEOId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | Product$shopArgs<ExtArgs>
    ProductSEO?: boolean | Product$ProductSEOArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    featuredMedia?: boolean | Product$featuredMediaArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | Product$shopArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | Product$shopArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs> | null
      ProductSEO: Prisma.$ProductSEOPayload<ExtArgs> | null
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
      featuredMedia: Prisma.$ProductFeaturedMediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      handle: string
      description: string | null
      title: string | null
      tags: string[]
      onlineStoreUrl: string
      shopId: string | null
      createdAt: Date
      updatedAt: Date
      productSEOId: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends Product$shopArgs<ExtArgs> = {}>(args?: Subset<T, Product$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProductSEO<T extends Product$ProductSEOArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductSEOArgs<ExtArgs>>): Prisma__ProductSEOClient<$Result.GetResult<Prisma.$ProductSEOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featuredMedia<T extends Product$featuredMediaArgs<ExtArgs> = {}>(args?: Subset<T, Product$featuredMediaArgs<ExtArgs>>): Prisma__ProductFeaturedMediaClient<$Result.GetResult<Prisma.$ProductFeaturedMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly shopifyId: FieldRef<"Product", 'String'>
    readonly handle: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly tags: FieldRef<"Product", 'String[]'>
    readonly onlineStoreUrl: FieldRef<"Product", 'String'>
    readonly shopId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly productSEOId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.shop
   */
  export type Product$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Product.ProductSEO
   */
  export type Product$ProductSEOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSEO
     */
    select?: ProductSEOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSEO
     */
    omit?: ProductSEOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSEOInclude<ExtArgs> | null
    where?: ProductSEOWhereInput
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product.featuredMedia
   */
  export type Product$featuredMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFeaturedMedia
     */
    select?: ProductFeaturedMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFeaturedMedia
     */
    omit?: ProductFeaturedMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFeaturedMediaInclude<ExtArgs> | null
    where?: ProductFeaturedMediaWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model OrderPrice
   */

  export type AggregateOrderPrice = {
    _count: OrderPriceCountAggregateOutputType | null
    _avg: OrderPriceAvgAggregateOutputType | null
    _sum: OrderPriceSumAggregateOutputType | null
    _min: OrderPriceMinAggregateOutputType | null
    _max: OrderPriceMaxAggregateOutputType | null
  }

  export type OrderPriceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type OrderPriceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type OrderPriceMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    currencyCode: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderPriceMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    currencyCode: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderPriceCountAggregateOutputType = {
    id: number
    amount: number
    currencyCode: number
    orderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderPriceAvgAggregateInputType = {
    amount?: true
  }

  export type OrderPriceSumAggregateInputType = {
    amount?: true
  }

  export type OrderPriceMinAggregateInputType = {
    id?: true
    amount?: true
    currencyCode?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderPriceMaxAggregateInputType = {
    id?: true
    amount?: true
    currencyCode?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderPriceCountAggregateInputType = {
    id?: true
    amount?: true
    currencyCode?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderPrice to aggregate.
     */
    where?: OrderPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPrices to fetch.
     */
    orderBy?: OrderPriceOrderByWithRelationInput | OrderPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderPrices
    **/
    _count?: true | OrderPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderPriceMaxAggregateInputType
  }

  export type GetOrderPriceAggregateType<T extends OrderPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderPrice[P]>
      : GetScalarType<T[P], AggregateOrderPrice[P]>
  }




  export type OrderPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderPriceWhereInput
    orderBy?: OrderPriceOrderByWithAggregationInput | OrderPriceOrderByWithAggregationInput[]
    by: OrderPriceScalarFieldEnum[] | OrderPriceScalarFieldEnum
    having?: OrderPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderPriceCountAggregateInputType | true
    _avg?: OrderPriceAvgAggregateInputType
    _sum?: OrderPriceSumAggregateInputType
    _min?: OrderPriceMinAggregateInputType
    _max?: OrderPriceMaxAggregateInputType
  }

  export type OrderPriceGroupByOutputType = {
    id: string
    amount: Decimal
    currencyCode: string
    orderId: string
    createdAt: Date
    updatedAt: Date
    _count: OrderPriceCountAggregateOutputType | null
    _avg: OrderPriceAvgAggregateOutputType | null
    _sum: OrderPriceSumAggregateOutputType | null
    _min: OrderPriceMinAggregateOutputType | null
    _max: OrderPriceMaxAggregateOutputType | null
  }

  type GetOrderPriceGroupByPayload<T extends OrderPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderPriceGroupByOutputType[P]>
            : GetScalarType<T[P], OrderPriceGroupByOutputType[P]>
        }
      >
    >


  export type OrderPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currencyCode?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderPrice"]>

  export type OrderPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currencyCode?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderPrice"]>

  export type OrderPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currencyCode?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderPrice"]>

  export type OrderPriceSelectScalar = {
    id?: boolean
    amount?: boolean
    currencyCode?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "currencyCode" | "orderId" | "createdAt" | "updatedAt", ExtArgs["result"]["orderPrice"]>
  export type OrderPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderPrice"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      currencyCode: string
      orderId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderPrice"]>
    composites: {}
  }

  type OrderPriceGetPayload<S extends boolean | null | undefined | OrderPriceDefaultArgs> = $Result.GetResult<Prisma.$OrderPricePayload, S>

  type OrderPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderPriceCountAggregateInputType | true
    }

  export interface OrderPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderPrice'], meta: { name: 'OrderPrice' } }
    /**
     * Find zero or one OrderPrice that matches the filter.
     * @param {OrderPriceFindUniqueArgs} args - Arguments to find a OrderPrice
     * @example
     * // Get one OrderPrice
     * const orderPrice = await prisma.orderPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderPriceFindUniqueArgs>(args: SelectSubset<T, OrderPriceFindUniqueArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderPriceFindUniqueOrThrowArgs} args - Arguments to find a OrderPrice
     * @example
     * // Get one OrderPrice
     * const orderPrice = await prisma.orderPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceFindFirstArgs} args - Arguments to find a OrderPrice
     * @example
     * // Get one OrderPrice
     * const orderPrice = await prisma.orderPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderPriceFindFirstArgs>(args?: SelectSubset<T, OrderPriceFindFirstArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceFindFirstOrThrowArgs} args - Arguments to find a OrderPrice
     * @example
     * // Get one OrderPrice
     * const orderPrice = await prisma.orderPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderPrices
     * const orderPrices = await prisma.orderPrice.findMany()
     * 
     * // Get first 10 OrderPrices
     * const orderPrices = await prisma.orderPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderPriceWithIdOnly = await prisma.orderPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderPriceFindManyArgs>(args?: SelectSubset<T, OrderPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderPrice.
     * @param {OrderPriceCreateArgs} args - Arguments to create a OrderPrice.
     * @example
     * // Create one OrderPrice
     * const OrderPrice = await prisma.orderPrice.create({
     *   data: {
     *     // ... data to create a OrderPrice
     *   }
     * })
     * 
     */
    create<T extends OrderPriceCreateArgs>(args: SelectSubset<T, OrderPriceCreateArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderPrices.
     * @param {OrderPriceCreateManyArgs} args - Arguments to create many OrderPrices.
     * @example
     * // Create many OrderPrices
     * const orderPrice = await prisma.orderPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderPriceCreateManyArgs>(args?: SelectSubset<T, OrderPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderPrices and returns the data saved in the database.
     * @param {OrderPriceCreateManyAndReturnArgs} args - Arguments to create many OrderPrices.
     * @example
     * // Create many OrderPrices
     * const orderPrice = await prisma.orderPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderPrices and only return the `id`
     * const orderPriceWithIdOnly = await prisma.orderPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderPrice.
     * @param {OrderPriceDeleteArgs} args - Arguments to delete one OrderPrice.
     * @example
     * // Delete one OrderPrice
     * const OrderPrice = await prisma.orderPrice.delete({
     *   where: {
     *     // ... filter to delete one OrderPrice
     *   }
     * })
     * 
     */
    delete<T extends OrderPriceDeleteArgs>(args: SelectSubset<T, OrderPriceDeleteArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderPrice.
     * @param {OrderPriceUpdateArgs} args - Arguments to update one OrderPrice.
     * @example
     * // Update one OrderPrice
     * const orderPrice = await prisma.orderPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderPriceUpdateArgs>(args: SelectSubset<T, OrderPriceUpdateArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderPrices.
     * @param {OrderPriceDeleteManyArgs} args - Arguments to filter OrderPrices to delete.
     * @example
     * // Delete a few OrderPrices
     * const { count } = await prisma.orderPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderPriceDeleteManyArgs>(args?: SelectSubset<T, OrderPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderPrices
     * const orderPrice = await prisma.orderPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderPriceUpdateManyArgs>(args: SelectSubset<T, OrderPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPrices and returns the data updated in the database.
     * @param {OrderPriceUpdateManyAndReturnArgs} args - Arguments to update many OrderPrices.
     * @example
     * // Update many OrderPrices
     * const orderPrice = await prisma.orderPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderPrices and only return the `id`
     * const orderPriceWithIdOnly = await prisma.orderPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderPrice.
     * @param {OrderPriceUpsertArgs} args - Arguments to update or create a OrderPrice.
     * @example
     * // Update or create a OrderPrice
     * const orderPrice = await prisma.orderPrice.upsert({
     *   create: {
     *     // ... data to create a OrderPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderPrice we want to update
     *   }
     * })
     */
    upsert<T extends OrderPriceUpsertArgs>(args: SelectSubset<T, OrderPriceUpsertArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceCountArgs} args - Arguments to filter OrderPrices to count.
     * @example
     * // Count the number of OrderPrices
     * const count = await prisma.orderPrice.count({
     *   where: {
     *     // ... the filter for the OrderPrices we want to count
     *   }
     * })
    **/
    count<T extends OrderPriceCountArgs>(
      args?: Subset<T, OrderPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderPriceAggregateArgs>(args: Subset<T, OrderPriceAggregateArgs>): Prisma.PrismaPromise<GetOrderPriceAggregateType<T>>

    /**
     * Group by OrderPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderPriceGroupByArgs['orderBy'] }
        : { orderBy?: OrderPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderPrice model
   */
  readonly fields: OrderPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderPrice model
   */ 
  interface OrderPriceFieldRefs {
    readonly id: FieldRef<"OrderPrice", 'String'>
    readonly amount: FieldRef<"OrderPrice", 'Decimal'>
    readonly currencyCode: FieldRef<"OrderPrice", 'String'>
    readonly orderId: FieldRef<"OrderPrice", 'String'>
    readonly createdAt: FieldRef<"OrderPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderPrice findUnique
   */
  export type OrderPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter, which OrderPrice to fetch.
     */
    where: OrderPriceWhereUniqueInput
  }

  /**
   * OrderPrice findUniqueOrThrow
   */
  export type OrderPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter, which OrderPrice to fetch.
     */
    where: OrderPriceWhereUniqueInput
  }

  /**
   * OrderPrice findFirst
   */
  export type OrderPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter, which OrderPrice to fetch.
     */
    where?: OrderPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPrices to fetch.
     */
    orderBy?: OrderPriceOrderByWithRelationInput | OrderPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderPrices.
     */
    cursor?: OrderPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderPrices.
     */
    distinct?: OrderPriceScalarFieldEnum | OrderPriceScalarFieldEnum[]
  }

  /**
   * OrderPrice findFirstOrThrow
   */
  export type OrderPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter, which OrderPrice to fetch.
     */
    where?: OrderPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPrices to fetch.
     */
    orderBy?: OrderPriceOrderByWithRelationInput | OrderPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderPrices.
     */
    cursor?: OrderPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderPrices.
     */
    distinct?: OrderPriceScalarFieldEnum | OrderPriceScalarFieldEnum[]
  }

  /**
   * OrderPrice findMany
   */
  export type OrderPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter, which OrderPrices to fetch.
     */
    where?: OrderPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPrices to fetch.
     */
    orderBy?: OrderPriceOrderByWithRelationInput | OrderPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderPrices.
     */
    cursor?: OrderPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPrices.
     */
    skip?: number
    distinct?: OrderPriceScalarFieldEnum | OrderPriceScalarFieldEnum[]
  }

  /**
   * OrderPrice create
   */
  export type OrderPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderPrice.
     */
    data: XOR<OrderPriceCreateInput, OrderPriceUncheckedCreateInput>
  }

  /**
   * OrderPrice createMany
   */
  export type OrderPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderPrices.
     */
    data: OrderPriceCreateManyInput | OrderPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderPrice createManyAndReturn
   */
  export type OrderPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * The data used to create many OrderPrices.
     */
    data: OrderPriceCreateManyInput | OrderPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderPrice update
   */
  export type OrderPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderPrice.
     */
    data: XOR<OrderPriceUpdateInput, OrderPriceUncheckedUpdateInput>
    /**
     * Choose, which OrderPrice to update.
     */
    where: OrderPriceWhereUniqueInput
  }

  /**
   * OrderPrice updateMany
   */
  export type OrderPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderPrices.
     */
    data: XOR<OrderPriceUpdateManyMutationInput, OrderPriceUncheckedUpdateManyInput>
    /**
     * Filter which OrderPrices to update
     */
    where?: OrderPriceWhereInput
    /**
     * Limit how many OrderPrices to update.
     */
    limit?: number
  }

  /**
   * OrderPrice updateManyAndReturn
   */
  export type OrderPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * The data used to update OrderPrices.
     */
    data: XOR<OrderPriceUpdateManyMutationInput, OrderPriceUncheckedUpdateManyInput>
    /**
     * Filter which OrderPrices to update
     */
    where?: OrderPriceWhereInput
    /**
     * Limit how many OrderPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderPrice upsert
   */
  export type OrderPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderPrice to update in case it exists.
     */
    where: OrderPriceWhereUniqueInput
    /**
     * In case the OrderPrice found by the `where` argument doesn't exist, create a new OrderPrice with this data.
     */
    create: XOR<OrderPriceCreateInput, OrderPriceUncheckedCreateInput>
    /**
     * In case the OrderPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderPriceUpdateInput, OrderPriceUncheckedUpdateInput>
  }

  /**
   * OrderPrice delete
   */
  export type OrderPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    /**
     * Filter which OrderPrice to delete.
     */
    where: OrderPriceWhereUniqueInput
  }

  /**
   * OrderPrice deleteMany
   */
  export type OrderPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderPrices to delete
     */
    where?: OrderPriceWhereInput
    /**
     * Limit how many OrderPrices to delete.
     */
    limit?: number
  }

  /**
   * OrderPrice without action
   */
  export type OrderPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    name: string | null
    shopifyId: string | null
    unpaid: boolean | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    orderPriceId: string | null
    shopId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shopifyId: string | null
    unpaid: boolean | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    orderPriceId: string | null
    shopId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    name: number
    shopifyId: number
    unpaid: number
    processedAt: number
    createdAt: number
    updatedAt: number
    orderPriceId: number
    shopId: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    name?: true
    shopifyId?: true
    unpaid?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    orderPriceId?: true
    shopId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    name?: true
    shopifyId?: true
    unpaid?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    orderPriceId?: true
    shopId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    name?: true
    shopifyId?: true
    unpaid?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    orderPriceId?: true
    shopId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    name: string
    shopifyId: string
    unpaid: boolean
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    orderPriceId: string | null
    shopId: string | null
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shopifyId?: boolean
    unpaid?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderPriceId?: boolean
    shopId?: boolean
    orderPrice?: boolean | Order$orderPriceArgs<ExtArgs>
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shopifyId?: boolean
    unpaid?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderPriceId?: boolean
    shopId?: boolean
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shopifyId?: boolean
    unpaid?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderPriceId?: boolean
    shopId?: boolean
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    name?: boolean
    shopifyId?: boolean
    unpaid?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderPriceId?: boolean
    shopId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shopifyId" | "unpaid" | "processedAt" | "createdAt" | "updatedAt" | "orderPriceId" | "shopId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderPrice?: boolean | Order$orderPriceArgs<ExtArgs>
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | Order$ShopArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderPrice: Prisma.$OrderPricePayload<ExtArgs> | null
      Shop: Prisma.$ShopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shopifyId: string
      unpaid: boolean
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
      orderPriceId: string | null
      shopId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderPrice<T extends Order$orderPriceArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderPriceArgs<ExtArgs>>): Prisma__OrderPriceClient<$Result.GetResult<Prisma.$OrderPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Shop<T extends Order$ShopArgs<ExtArgs> = {}>(args?: Subset<T, Order$ShopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly name: FieldRef<"Order", 'String'>
    readonly shopifyId: FieldRef<"Order", 'String'>
    readonly unpaid: FieldRef<"Order", 'Boolean'>
    readonly processedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly orderPriceId: FieldRef<"Order", 'String'>
    readonly shopId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.orderPrice
   */
  export type Order$orderPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPrice
     */
    select?: OrderPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPrice
     */
    omit?: OrderPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPriceInclude<ExtArgs> | null
    where?: OrderPriceWhereInput
  }

  /**
   * Order.Shop
   */
  export type Order$ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model CollectionImage
   */

  export type AggregateCollectionImage = {
    _count: CollectionImageCountAggregateOutputType | null
    _min: CollectionImageMinAggregateOutputType | null
    _max: CollectionImageMaxAggregateOutputType | null
  }

  export type CollectionImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    collectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    collectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionImageCountAggregateOutputType = {
    id: number
    url: number
    collectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionImageMinAggregateInputType = {
    id?: true
    url?: true
    collectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionImageMaxAggregateInputType = {
    id?: true
    url?: true
    collectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionImageCountAggregateInputType = {
    id?: true
    url?: true
    collectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionImage to aggregate.
     */
    where?: CollectionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionImages to fetch.
     */
    orderBy?: CollectionImageOrderByWithRelationInput | CollectionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionImages
    **/
    _count?: true | CollectionImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionImageMaxAggregateInputType
  }

  export type GetCollectionImageAggregateType<T extends CollectionImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionImage[P]>
      : GetScalarType<T[P], AggregateCollectionImage[P]>
  }




  export type CollectionImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionImageWhereInput
    orderBy?: CollectionImageOrderByWithAggregationInput | CollectionImageOrderByWithAggregationInput[]
    by: CollectionImageScalarFieldEnum[] | CollectionImageScalarFieldEnum
    having?: CollectionImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionImageCountAggregateInputType | true
    _min?: CollectionImageMinAggregateInputType
    _max?: CollectionImageMaxAggregateInputType
  }

  export type CollectionImageGroupByOutputType = {
    id: string
    url: string | null
    collectionId: string
    createdAt: Date
    updatedAt: Date
    _count: CollectionImageCountAggregateOutputType | null
    _min: CollectionImageMinAggregateOutputType | null
    _max: CollectionImageMaxAggregateOutputType | null
  }

  type GetCollectionImageGroupByPayload<T extends CollectionImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionImageGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionImageGroupByOutputType[P]>
        }
      >
    >


  export type CollectionImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    collectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionImage"]>

  export type CollectionImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    collectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionImage"]>

  export type CollectionImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    collectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionImage"]>

  export type CollectionImageSelectScalar = {
    id?: boolean
    url?: boolean
    collectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "collectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionImage"]>
  export type CollectionImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type CollectionImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type CollectionImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }

  export type $CollectionImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionImage"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string | null
      collectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionImage"]>
    composites: {}
  }

  type CollectionImageGetPayload<S extends boolean | null | undefined | CollectionImageDefaultArgs> = $Result.GetResult<Prisma.$CollectionImagePayload, S>

  type CollectionImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionImageCountAggregateInputType | true
    }

  export interface CollectionImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionImage'], meta: { name: 'CollectionImage' } }
    /**
     * Find zero or one CollectionImage that matches the filter.
     * @param {CollectionImageFindUniqueArgs} args - Arguments to find a CollectionImage
     * @example
     * // Get one CollectionImage
     * const collectionImage = await prisma.collectionImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionImageFindUniqueArgs>(args: SelectSubset<T, CollectionImageFindUniqueArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionImageFindUniqueOrThrowArgs} args - Arguments to find a CollectionImage
     * @example
     * // Get one CollectionImage
     * const collectionImage = await prisma.collectionImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageFindFirstArgs} args - Arguments to find a CollectionImage
     * @example
     * // Get one CollectionImage
     * const collectionImage = await prisma.collectionImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionImageFindFirstArgs>(args?: SelectSubset<T, CollectionImageFindFirstArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageFindFirstOrThrowArgs} args - Arguments to find a CollectionImage
     * @example
     * // Get one CollectionImage
     * const collectionImage = await prisma.collectionImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionImages
     * const collectionImages = await prisma.collectionImage.findMany()
     * 
     * // Get first 10 CollectionImages
     * const collectionImages = await prisma.collectionImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionImageWithIdOnly = await prisma.collectionImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionImageFindManyArgs>(args?: SelectSubset<T, CollectionImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionImage.
     * @param {CollectionImageCreateArgs} args - Arguments to create a CollectionImage.
     * @example
     * // Create one CollectionImage
     * const CollectionImage = await prisma.collectionImage.create({
     *   data: {
     *     // ... data to create a CollectionImage
     *   }
     * })
     * 
     */
    create<T extends CollectionImageCreateArgs>(args: SelectSubset<T, CollectionImageCreateArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionImages.
     * @param {CollectionImageCreateManyArgs} args - Arguments to create many CollectionImages.
     * @example
     * // Create many CollectionImages
     * const collectionImage = await prisma.collectionImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionImageCreateManyArgs>(args?: SelectSubset<T, CollectionImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionImages and returns the data saved in the database.
     * @param {CollectionImageCreateManyAndReturnArgs} args - Arguments to create many CollectionImages.
     * @example
     * // Create many CollectionImages
     * const collectionImage = await prisma.collectionImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionImages and only return the `id`
     * const collectionImageWithIdOnly = await prisma.collectionImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionImage.
     * @param {CollectionImageDeleteArgs} args - Arguments to delete one CollectionImage.
     * @example
     * // Delete one CollectionImage
     * const CollectionImage = await prisma.collectionImage.delete({
     *   where: {
     *     // ... filter to delete one CollectionImage
     *   }
     * })
     * 
     */
    delete<T extends CollectionImageDeleteArgs>(args: SelectSubset<T, CollectionImageDeleteArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionImage.
     * @param {CollectionImageUpdateArgs} args - Arguments to update one CollectionImage.
     * @example
     * // Update one CollectionImage
     * const collectionImage = await prisma.collectionImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionImageUpdateArgs>(args: SelectSubset<T, CollectionImageUpdateArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionImages.
     * @param {CollectionImageDeleteManyArgs} args - Arguments to filter CollectionImages to delete.
     * @example
     * // Delete a few CollectionImages
     * const { count } = await prisma.collectionImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionImageDeleteManyArgs>(args?: SelectSubset<T, CollectionImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionImages
     * const collectionImage = await prisma.collectionImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionImageUpdateManyArgs>(args: SelectSubset<T, CollectionImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionImages and returns the data updated in the database.
     * @param {CollectionImageUpdateManyAndReturnArgs} args - Arguments to update many CollectionImages.
     * @example
     * // Update many CollectionImages
     * const collectionImage = await prisma.collectionImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionImages and only return the `id`
     * const collectionImageWithIdOnly = await prisma.collectionImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionImage.
     * @param {CollectionImageUpsertArgs} args - Arguments to update or create a CollectionImage.
     * @example
     * // Update or create a CollectionImage
     * const collectionImage = await prisma.collectionImage.upsert({
     *   create: {
     *     // ... data to create a CollectionImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionImage we want to update
     *   }
     * })
     */
    upsert<T extends CollectionImageUpsertArgs>(args: SelectSubset<T, CollectionImageUpsertArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageCountArgs} args - Arguments to filter CollectionImages to count.
     * @example
     * // Count the number of CollectionImages
     * const count = await prisma.collectionImage.count({
     *   where: {
     *     // ... the filter for the CollectionImages we want to count
     *   }
     * })
    **/
    count<T extends CollectionImageCountArgs>(
      args?: Subset<T, CollectionImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionImageAggregateArgs>(args: Subset<T, CollectionImageAggregateArgs>): Prisma.PrismaPromise<GetCollectionImageAggregateType<T>>

    /**
     * Group by CollectionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionImageGroupByArgs['orderBy'] }
        : { orderBy?: CollectionImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionImage model
   */
  readonly fields: CollectionImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionImage model
   */ 
  interface CollectionImageFieldRefs {
    readonly id: FieldRef<"CollectionImage", 'String'>
    readonly url: FieldRef<"CollectionImage", 'String'>
    readonly collectionId: FieldRef<"CollectionImage", 'String'>
    readonly createdAt: FieldRef<"CollectionImage", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionImage findUnique
   */
  export type CollectionImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter, which CollectionImage to fetch.
     */
    where: CollectionImageWhereUniqueInput
  }

  /**
   * CollectionImage findUniqueOrThrow
   */
  export type CollectionImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter, which CollectionImage to fetch.
     */
    where: CollectionImageWhereUniqueInput
  }

  /**
   * CollectionImage findFirst
   */
  export type CollectionImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter, which CollectionImage to fetch.
     */
    where?: CollectionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionImages to fetch.
     */
    orderBy?: CollectionImageOrderByWithRelationInput | CollectionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionImages.
     */
    cursor?: CollectionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionImages.
     */
    distinct?: CollectionImageScalarFieldEnum | CollectionImageScalarFieldEnum[]
  }

  /**
   * CollectionImage findFirstOrThrow
   */
  export type CollectionImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter, which CollectionImage to fetch.
     */
    where?: CollectionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionImages to fetch.
     */
    orderBy?: CollectionImageOrderByWithRelationInput | CollectionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionImages.
     */
    cursor?: CollectionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionImages.
     */
    distinct?: CollectionImageScalarFieldEnum | CollectionImageScalarFieldEnum[]
  }

  /**
   * CollectionImage findMany
   */
  export type CollectionImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter, which CollectionImages to fetch.
     */
    where?: CollectionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionImages to fetch.
     */
    orderBy?: CollectionImageOrderByWithRelationInput | CollectionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionImages.
     */
    cursor?: CollectionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionImages.
     */
    skip?: number
    distinct?: CollectionImageScalarFieldEnum | CollectionImageScalarFieldEnum[]
  }

  /**
   * CollectionImage create
   */
  export type CollectionImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionImage.
     */
    data: XOR<CollectionImageCreateInput, CollectionImageUncheckedCreateInput>
  }

  /**
   * CollectionImage createMany
   */
  export type CollectionImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionImages.
     */
    data: CollectionImageCreateManyInput | CollectionImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionImage createManyAndReturn
   */
  export type CollectionImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionImages.
     */
    data: CollectionImageCreateManyInput | CollectionImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionImage update
   */
  export type CollectionImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionImage.
     */
    data: XOR<CollectionImageUpdateInput, CollectionImageUncheckedUpdateInput>
    /**
     * Choose, which CollectionImage to update.
     */
    where: CollectionImageWhereUniqueInput
  }

  /**
   * CollectionImage updateMany
   */
  export type CollectionImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionImages.
     */
    data: XOR<CollectionImageUpdateManyMutationInput, CollectionImageUncheckedUpdateManyInput>
    /**
     * Filter which CollectionImages to update
     */
    where?: CollectionImageWhereInput
    /**
     * Limit how many CollectionImages to update.
     */
    limit?: number
  }

  /**
   * CollectionImage updateManyAndReturn
   */
  export type CollectionImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * The data used to update CollectionImages.
     */
    data: XOR<CollectionImageUpdateManyMutationInput, CollectionImageUncheckedUpdateManyInput>
    /**
     * Filter which CollectionImages to update
     */
    where?: CollectionImageWhereInput
    /**
     * Limit how many CollectionImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionImage upsert
   */
  export type CollectionImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionImage to update in case it exists.
     */
    where: CollectionImageWhereUniqueInput
    /**
     * In case the CollectionImage found by the `where` argument doesn't exist, create a new CollectionImage with this data.
     */
    create: XOR<CollectionImageCreateInput, CollectionImageUncheckedCreateInput>
    /**
     * In case the CollectionImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionImageUpdateInput, CollectionImageUncheckedUpdateInput>
  }

  /**
   * CollectionImage delete
   */
  export type CollectionImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    /**
     * Filter which CollectionImage to delete.
     */
    where: CollectionImageWhereUniqueInput
  }

  /**
   * CollectionImage deleteMany
   */
  export type CollectionImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionImages to delete
     */
    where?: CollectionImageWhereInput
    /**
     * Limit how many CollectionImages to delete.
     */
    limit?: number
  }

  /**
   * CollectionImage without action
   */
  export type CollectionImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
  }


  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    title: string | null
    description: string | null
    handle: string | null
    collectionImageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: string | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    title: string | null
    description: string | null
    handle: string | null
    collectionImageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: string | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    shopifyId: number
    title: number
    description: number
    handle: number
    collectionImageId: number
    createdAt: number
    updatedAt: number
    shopId: number
    _all: number
  }


  export type CollectionMinAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    description?: true
    handle?: true
    collectionImageId?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    description?: true
    handle?: true
    collectionImageId?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    shopifyId?: true
    title?: true
    description?: true
    handle?: true
    collectionImageId?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: CollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: string
    shopifyId: string
    title: string | null
    description: string | null
    handle: string
    collectionImageId: string | null
    createdAt: Date
    updatedAt: Date
    shopId: string | null
    _count: CollectionCountAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    description?: boolean
    handle?: boolean
    collectionImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    collectionImage?: boolean | Collection$collectionImageArgs<ExtArgs>
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    description?: boolean
    handle?: boolean
    collectionImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    description?: boolean
    handle?: boolean
    collectionImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    title?: boolean
    description?: boolean
    handle?: boolean
    collectionImageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
  }

  export type CollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "title" | "description" | "handle" | "collectionImageId" | "createdAt" | "updatedAt" | "shopId", ExtArgs["result"]["collection"]>
  export type CollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionImage?: boolean | Collection$collectionImageArgs<ExtArgs>
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }
  export type CollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }
  export type CollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shop?: boolean | Collection$ShopArgs<ExtArgs>
  }

  export type $CollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collection"
    objects: {
      collectionImage: Prisma.$CollectionImagePayload<ExtArgs> | null
      Shop: Prisma.$ShopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      title: string | null
      description: string | null
      handle: string
      collectionImageId: string | null
      createdAt: Date
      updatedAt: Date
      shopId: string | null
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> = $Result.GetResult<Prisma.$CollectionPayload, S>

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface CollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collection'], meta: { name: 'Collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionFindManyArgs>(args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends CollectionCreateArgs>(args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCreateManyArgs>(args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends CollectionDeleteArgs>(args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionUpdateArgs>(args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionDeleteManyArgs>(args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionUpdateManyArgs>(args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections and returns the data updated in the database.
     * @param {CollectionUpdateManyAndReturnArgs} args - Arguments to update many Collections.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collection model
   */
  readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionImage<T extends Collection$collectionImageArgs<ExtArgs> = {}>(args?: Subset<T, Collection$collectionImageArgs<ExtArgs>>): Prisma__CollectionImageClient<$Result.GetResult<Prisma.$CollectionImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Shop<T extends Collection$ShopArgs<ExtArgs> = {}>(args?: Subset<T, Collection$ShopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collection model
   */ 
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", 'String'>
    readonly shopifyId: FieldRef<"Collection", 'String'>
    readonly title: FieldRef<"Collection", 'String'>
    readonly description: FieldRef<"Collection", 'String'>
    readonly handle: FieldRef<"Collection", 'String'>
    readonly collectionImageId: FieldRef<"Collection", 'String'>
    readonly createdAt: FieldRef<"Collection", 'DateTime'>
    readonly updatedAt: FieldRef<"Collection", 'DateTime'>
    readonly shopId: FieldRef<"Collection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection create
   */
  export type CollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Collection.
     */
    data: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
  }

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
  }

  /**
   * Collection updateManyAndReturn
   */
  export type CollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
  }

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to delete.
     */
    limit?: number
  }

  /**
   * Collection.collectionImage
   */
  export type Collection$collectionImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionImage
     */
    select?: CollectionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionImage
     */
    omit?: CollectionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionImageInclude<ExtArgs> | null
    where?: CollectionImageWhereInput
  }

  /**
   * Collection.Shop
   */
  export type Collection$ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopMinAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    myshopifyDomain: string | null
    name: string | null
    description: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ShopMaxAggregateOutputType = {
    id: string | null
    shopifyId: string | null
    myshopifyDomain: string | null
    name: string | null
    description: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    shopifyId: number
    myshopifyDomain: number
    name: number
    description: number
    shipsToCountries: number
    accessToken: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ShopMinAggregateInputType = {
    id?: true
    shopifyId?: true
    myshopifyDomain?: true
    name?: true
    description?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    shopifyId?: true
    myshopifyDomain?: true
    name?: true
    description?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    shopifyId?: true
    myshopifyDomain?: true
    name?: true
    description?: true
    shipsToCountries?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description: string | null
    shipsToCountries: string[]
    accessToken: string
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: ShopCountAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    myshopifyDomain?: boolean
    name?: boolean
    description?: boolean
    shipsToCountries?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    products?: boolean | Shop$productsArgs<ExtArgs>
    orders?: boolean | Shop$ordersArgs<ExtArgs>
    collections?: boolean | Shop$collectionsArgs<ExtArgs>
    User?: boolean | Shop$UserArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    myshopifyDomain?: boolean
    name?: boolean
    description?: boolean
    shipsToCountries?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | Shop$UserArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyId?: boolean
    myshopifyDomain?: boolean
    name?: boolean
    description?: boolean
    shipsToCountries?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    User?: boolean | Shop$UserArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    id?: boolean
    shopifyId?: boolean
    myshopifyDomain?: boolean
    name?: boolean
    description?: boolean
    shipsToCountries?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyId" | "myshopifyDomain" | "name" | "description" | "shipsToCountries" | "accessToken" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["shop"]>
  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Shop$productsArgs<ExtArgs>
    orders?: boolean | Shop$ordersArgs<ExtArgs>
    collections?: boolean | Shop$collectionsArgs<ExtArgs>
    User?: boolean | Shop$UserArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Shop$UserArgs<ExtArgs>
  }
  export type ShopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Shop$UserArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      collections: Prisma.$CollectionPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyId: string
      /**
       * Le 's' est en minuscule. Respecte l'API graphql Admin de shopify.
       */
      myshopifyDomain: string
      name: string
      description: string | null
      shipsToCountries: string[]
      accessToken: string
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shops and returns the data saved in the database.
     * @param {ShopCreateManyAndReturnArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops and returns the data updated in the database.
     * @param {ShopUpdateManyAndReturnArgs} args - Arguments to update many Shops.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Shop$productsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Shop$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Shop$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collections<T extends Shop$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Shop$UserArgs<ExtArgs> = {}>(args?: Subset<T, Shop$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */ 
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'String'>
    readonly shopifyId: FieldRef<"Shop", 'String'>
    readonly myshopifyDomain: FieldRef<"Shop", 'String'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly description: FieldRef<"Shop", 'String'>
    readonly shipsToCountries: FieldRef<"Shop", 'String[]'>
    readonly accessToken: FieldRef<"Shop", 'String'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
    readonly userId: FieldRef<"Shop", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop createManyAndReturn
   */
  export type ShopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
  }

  /**
   * Shop updateManyAndReturn
   */
  export type ShopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to delete.
     */
    limit?: number
  }

  /**
   * Shop.products
   */
  export type Shop$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Shop.orders
   */
  export type Shop$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Shop.collections
   */
  export type Shop$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Shop.User
   */
  export type Shop$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    shops?: boolean | User$shopsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    shops?: boolean | User$shopsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      shops: Prisma.$ShopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shops<T extends User$shopsArgs<ExtArgs> = {}>(args?: Subset<T, User$shopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.shops
   */
  export type User$shopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FeaturedMediaVideoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    productFeaturedMediaId: 'productFeaturedMediaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedMediaVideoScalarFieldEnum = (typeof FeaturedMediaVideoScalarFieldEnum)[keyof typeof FeaturedMediaVideoScalarFieldEnum]


  export const FeaturedMediaExternalVideoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    productFeaturedMediaId: 'productFeaturedMediaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedMediaExternalVideoScalarFieldEnum = (typeof FeaturedMediaExternalVideoScalarFieldEnum)[keyof typeof FeaturedMediaExternalVideoScalarFieldEnum]


  export const FeaturedMediaImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    productFeaturedMediaId: 'productFeaturedMediaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedMediaImageScalarFieldEnum = (typeof FeaturedMediaImageScalarFieldEnum)[keyof typeof FeaturedMediaImageScalarFieldEnum]


  export const ProductFeaturedMediaScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    alt: 'alt',
    mediaContentType: 'mediaContentType',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    featuredMediaVideoId: 'featuredMediaVideoId',
    featuredMediaExternalVideoId: 'featuredMediaExternalVideoId',
    featuredMediaImageId: 'featuredMediaImageId'
  };

  export type ProductFeaturedMediaScalarFieldEnum = (typeof ProductFeaturedMediaScalarFieldEnum)[keyof typeof ProductFeaturedMediaScalarFieldEnum]


  export const ProductSEOScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductSEOScalarFieldEnum = (typeof ProductSEOScalarFieldEnum)[keyof typeof ProductSEOScalarFieldEnum]


  export const ProductVariantProductScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    handle: 'handle',
    onlineStoreUrl: 'onlineStoreUrl',
    productVariantId: 'productVariantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantProductScalarFieldEnum = (typeof ProductVariantProductScalarFieldEnum)[keyof typeof ProductVariantProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    title: 'title',
    productId: 'productId',
    productVariantProductId: 'productVariantProductId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    handle: 'handle',
    description: 'description',
    title: 'title',
    tags: 'tags',
    onlineStoreUrl: 'onlineStoreUrl',
    shopId: 'shopId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productSEOId: 'productSEOId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderPriceScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currencyCode: 'currencyCode',
    orderId: 'orderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderPriceScalarFieldEnum = (typeof OrderPriceScalarFieldEnum)[keyof typeof OrderPriceScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shopifyId: 'shopifyId',
    unpaid: 'unpaid',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderPriceId: 'orderPriceId',
    shopId: 'shopId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CollectionImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    collectionId: 'collectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionImageScalarFieldEnum = (typeof CollectionImageScalarFieldEnum)[keyof typeof CollectionImageScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    title: 'title',
    description: 'description',
    handle: 'handle',
    collectionImageId: 'collectionImageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    shopId: 'shopId'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    shopifyId: 'shopifyId',
    myshopifyDomain: 'myshopifyDomain',
    name: 'name',
    description: 'description',
    shipsToCountries: 'shipsToCountries',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MediaContentType'
   */
  export type EnumMediaContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaContentType'>
    


  /**
   * Reference to a field of type 'MediaContentType[]'
   */
  export type ListEnumMediaContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaContentType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type FeaturedMediaVideoWhereInput = {
    AND?: FeaturedMediaVideoWhereInput | FeaturedMediaVideoWhereInput[]
    OR?: FeaturedMediaVideoWhereInput[]
    NOT?: FeaturedMediaVideoWhereInput | FeaturedMediaVideoWhereInput[]
    id?: StringFilter<"FeaturedMediaVideo"> | string
    url?: StringFilter<"FeaturedMediaVideo"> | string
    productFeaturedMediaId?: StringFilter<"FeaturedMediaVideo"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaVideo"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaVideo"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }

  export type FeaturedMediaVideoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productFeaturedMedia?: ProductFeaturedMediaOrderByWithRelationInput
  }

  export type FeaturedMediaVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productFeaturedMediaId?: string
    AND?: FeaturedMediaVideoWhereInput | FeaturedMediaVideoWhereInput[]
    OR?: FeaturedMediaVideoWhereInput[]
    NOT?: FeaturedMediaVideoWhereInput | FeaturedMediaVideoWhereInput[]
    url?: StringFilter<"FeaturedMediaVideo"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaVideo"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaVideo"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }, "id" | "productFeaturedMediaId">

  export type FeaturedMediaVideoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedMediaVideoCountOrderByAggregateInput
    _max?: FeaturedMediaVideoMaxOrderByAggregateInput
    _min?: FeaturedMediaVideoMinOrderByAggregateInput
  }

  export type FeaturedMediaVideoScalarWhereWithAggregatesInput = {
    AND?: FeaturedMediaVideoScalarWhereWithAggregatesInput | FeaturedMediaVideoScalarWhereWithAggregatesInput[]
    OR?: FeaturedMediaVideoScalarWhereWithAggregatesInput[]
    NOT?: FeaturedMediaVideoScalarWhereWithAggregatesInput | FeaturedMediaVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedMediaVideo"> | string
    url?: StringWithAggregatesFilter<"FeaturedMediaVideo"> | string
    productFeaturedMediaId?: StringWithAggregatesFilter<"FeaturedMediaVideo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedMediaVideo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedMediaVideo"> | Date | string
  }

  export type FeaturedMediaExternalVideoWhereInput = {
    AND?: FeaturedMediaExternalVideoWhereInput | FeaturedMediaExternalVideoWhereInput[]
    OR?: FeaturedMediaExternalVideoWhereInput[]
    NOT?: FeaturedMediaExternalVideoWhereInput | FeaturedMediaExternalVideoWhereInput[]
    id?: StringFilter<"FeaturedMediaExternalVideo"> | string
    url?: StringFilter<"FeaturedMediaExternalVideo"> | string
    productFeaturedMediaId?: StringFilter<"FeaturedMediaExternalVideo"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaExternalVideo"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaExternalVideo"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }

  export type FeaturedMediaExternalVideoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productFeaturedMedia?: ProductFeaturedMediaOrderByWithRelationInput
  }

  export type FeaturedMediaExternalVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productFeaturedMediaId?: string
    AND?: FeaturedMediaExternalVideoWhereInput | FeaturedMediaExternalVideoWhereInput[]
    OR?: FeaturedMediaExternalVideoWhereInput[]
    NOT?: FeaturedMediaExternalVideoWhereInput | FeaturedMediaExternalVideoWhereInput[]
    url?: StringFilter<"FeaturedMediaExternalVideo"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaExternalVideo"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaExternalVideo"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }, "id" | "productFeaturedMediaId">

  export type FeaturedMediaExternalVideoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedMediaExternalVideoCountOrderByAggregateInput
    _max?: FeaturedMediaExternalVideoMaxOrderByAggregateInput
    _min?: FeaturedMediaExternalVideoMinOrderByAggregateInput
  }

  export type FeaturedMediaExternalVideoScalarWhereWithAggregatesInput = {
    AND?: FeaturedMediaExternalVideoScalarWhereWithAggregatesInput | FeaturedMediaExternalVideoScalarWhereWithAggregatesInput[]
    OR?: FeaturedMediaExternalVideoScalarWhereWithAggregatesInput[]
    NOT?: FeaturedMediaExternalVideoScalarWhereWithAggregatesInput | FeaturedMediaExternalVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedMediaExternalVideo"> | string
    url?: StringWithAggregatesFilter<"FeaturedMediaExternalVideo"> | string
    productFeaturedMediaId?: StringWithAggregatesFilter<"FeaturedMediaExternalVideo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedMediaExternalVideo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedMediaExternalVideo"> | Date | string
  }

  export type FeaturedMediaImageWhereInput = {
    AND?: FeaturedMediaImageWhereInput | FeaturedMediaImageWhereInput[]
    OR?: FeaturedMediaImageWhereInput[]
    NOT?: FeaturedMediaImageWhereInput | FeaturedMediaImageWhereInput[]
    id?: StringFilter<"FeaturedMediaImage"> | string
    url?: StringFilter<"FeaturedMediaImage"> | string
    productFeaturedMediaId?: StringFilter<"FeaturedMediaImage"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaImage"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaImage"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }

  export type FeaturedMediaImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productFeaturedMedia?: ProductFeaturedMediaOrderByWithRelationInput
  }

  export type FeaturedMediaImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productFeaturedMediaId?: string
    AND?: FeaturedMediaImageWhereInput | FeaturedMediaImageWhereInput[]
    OR?: FeaturedMediaImageWhereInput[]
    NOT?: FeaturedMediaImageWhereInput | FeaturedMediaImageWhereInput[]
    url?: StringFilter<"FeaturedMediaImage"> | string
    createdAt?: DateTimeFilter<"FeaturedMediaImage"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedMediaImage"> | Date | string
    productFeaturedMedia?: XOR<ProductFeaturedMediaScalarRelationFilter, ProductFeaturedMediaWhereInput>
  }, "id" | "productFeaturedMediaId">

  export type FeaturedMediaImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedMediaImageCountOrderByAggregateInput
    _max?: FeaturedMediaImageMaxOrderByAggregateInput
    _min?: FeaturedMediaImageMinOrderByAggregateInput
  }

  export type FeaturedMediaImageScalarWhereWithAggregatesInput = {
    AND?: FeaturedMediaImageScalarWhereWithAggregatesInput | FeaturedMediaImageScalarWhereWithAggregatesInput[]
    OR?: FeaturedMediaImageScalarWhereWithAggregatesInput[]
    NOT?: FeaturedMediaImageScalarWhereWithAggregatesInput | FeaturedMediaImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedMediaImage"> | string
    url?: StringWithAggregatesFilter<"FeaturedMediaImage"> | string
    productFeaturedMediaId?: StringWithAggregatesFilter<"FeaturedMediaImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedMediaImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedMediaImage"> | Date | string
  }

  export type ProductFeaturedMediaWhereInput = {
    AND?: ProductFeaturedMediaWhereInput | ProductFeaturedMediaWhereInput[]
    OR?: ProductFeaturedMediaWhereInput[]
    NOT?: ProductFeaturedMediaWhereInput | ProductFeaturedMediaWhereInput[]
    id?: StringFilter<"ProductFeaturedMedia"> | string
    shopifyId?: StringFilter<"ProductFeaturedMedia"> | string
    alt?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    mediaContentType?: EnumMediaContentTypeFilter<"ProductFeaturedMedia"> | $Enums.MediaContentType
    productId?: StringFilter<"ProductFeaturedMedia"> | string
    createdAt?: DateTimeFilter<"ProductFeaturedMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ProductFeaturedMedia"> | Date | string
    featuredMediaVideoId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaExternalVideoId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaImageId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaVideo?: XOR<FeaturedMediaVideoNullableScalarRelationFilter, FeaturedMediaVideoWhereInput> | null
    featuredMediaExternalVideo?: XOR<FeaturedMediaExternalVideoNullableScalarRelationFilter, FeaturedMediaExternalVideoWhereInput> | null
    featuredMediaImage?: XOR<FeaturedMediaImageNullableScalarRelationFilter, FeaturedMediaImageWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductFeaturedMediaOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    alt?: SortOrderInput | SortOrder
    mediaContentType?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featuredMediaVideoId?: SortOrderInput | SortOrder
    featuredMediaExternalVideoId?: SortOrderInput | SortOrder
    featuredMediaImageId?: SortOrderInput | SortOrder
    featuredMediaVideo?: FeaturedMediaVideoOrderByWithRelationInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoOrderByWithRelationInput
    featuredMediaImage?: FeaturedMediaImageOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductFeaturedMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: ProductFeaturedMediaWhereInput | ProductFeaturedMediaWhereInput[]
    OR?: ProductFeaturedMediaWhereInput[]
    NOT?: ProductFeaturedMediaWhereInput | ProductFeaturedMediaWhereInput[]
    shopifyId?: StringFilter<"ProductFeaturedMedia"> | string
    alt?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    mediaContentType?: EnumMediaContentTypeFilter<"ProductFeaturedMedia"> | $Enums.MediaContentType
    createdAt?: DateTimeFilter<"ProductFeaturedMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ProductFeaturedMedia"> | Date | string
    featuredMediaVideoId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaExternalVideoId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaImageId?: StringNullableFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaVideo?: XOR<FeaturedMediaVideoNullableScalarRelationFilter, FeaturedMediaVideoWhereInput> | null
    featuredMediaExternalVideo?: XOR<FeaturedMediaExternalVideoNullableScalarRelationFilter, FeaturedMediaExternalVideoWhereInput> | null
    featuredMediaImage?: XOR<FeaturedMediaImageNullableScalarRelationFilter, FeaturedMediaImageWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type ProductFeaturedMediaOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    alt?: SortOrderInput | SortOrder
    mediaContentType?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featuredMediaVideoId?: SortOrderInput | SortOrder
    featuredMediaExternalVideoId?: SortOrderInput | SortOrder
    featuredMediaImageId?: SortOrderInput | SortOrder
    _count?: ProductFeaturedMediaCountOrderByAggregateInput
    _max?: ProductFeaturedMediaMaxOrderByAggregateInput
    _min?: ProductFeaturedMediaMinOrderByAggregateInput
  }

  export type ProductFeaturedMediaScalarWhereWithAggregatesInput = {
    AND?: ProductFeaturedMediaScalarWhereWithAggregatesInput | ProductFeaturedMediaScalarWhereWithAggregatesInput[]
    OR?: ProductFeaturedMediaScalarWhereWithAggregatesInput[]
    NOT?: ProductFeaturedMediaScalarWhereWithAggregatesInput | ProductFeaturedMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductFeaturedMedia"> | string
    shopifyId?: StringWithAggregatesFilter<"ProductFeaturedMedia"> | string
    alt?: StringNullableWithAggregatesFilter<"ProductFeaturedMedia"> | string | null
    mediaContentType?: EnumMediaContentTypeWithAggregatesFilter<"ProductFeaturedMedia"> | $Enums.MediaContentType
    productId?: StringWithAggregatesFilter<"ProductFeaturedMedia"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductFeaturedMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductFeaturedMedia"> | Date | string
    featuredMediaVideoId?: StringNullableWithAggregatesFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaExternalVideoId?: StringNullableWithAggregatesFilter<"ProductFeaturedMedia"> | string | null
    featuredMediaImageId?: StringNullableWithAggregatesFilter<"ProductFeaturedMedia"> | string | null
  }

  export type ProductSEOWhereInput = {
    AND?: ProductSEOWhereInput | ProductSEOWhereInput[]
    OR?: ProductSEOWhereInput[]
    NOT?: ProductSEOWhereInput | ProductSEOWhereInput[]
    id?: StringFilter<"ProductSEO"> | string
    title?: StringNullableFilter<"ProductSEO"> | string | null
    description?: StringNullableFilter<"ProductSEO"> | string | null
    productId?: StringFilter<"ProductSEO"> | string
    createdAt?: DateTimeFilter<"ProductSEO"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSEO"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductSEOOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductSEOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: ProductSEOWhereInput | ProductSEOWhereInput[]
    OR?: ProductSEOWhereInput[]
    NOT?: ProductSEOWhereInput | ProductSEOWhereInput[]
    title?: StringNullableFilter<"ProductSEO"> | string | null
    description?: StringNullableFilter<"ProductSEO"> | string | null
    createdAt?: DateTimeFilter<"ProductSEO"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSEO"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type ProductSEOOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductSEOCountOrderByAggregateInput
    _max?: ProductSEOMaxOrderByAggregateInput
    _min?: ProductSEOMinOrderByAggregateInput
  }

  export type ProductSEOScalarWhereWithAggregatesInput = {
    AND?: ProductSEOScalarWhereWithAggregatesInput | ProductSEOScalarWhereWithAggregatesInput[]
    OR?: ProductSEOScalarWhereWithAggregatesInput[]
    NOT?: ProductSEOScalarWhereWithAggregatesInput | ProductSEOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductSEO"> | string
    title?: StringNullableWithAggregatesFilter<"ProductSEO"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProductSEO"> | string | null
    productId?: StringWithAggregatesFilter<"ProductSEO"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductSEO"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductSEO"> | Date | string
  }

  export type ProductVariantProductWhereInput = {
    AND?: ProductVariantProductWhereInput | ProductVariantProductWhereInput[]
    OR?: ProductVariantProductWhereInput[]
    NOT?: ProductVariantProductWhereInput | ProductVariantProductWhereInput[]
    id?: StringFilter<"ProductVariantProduct"> | string
    shopifyId?: StringFilter<"ProductVariantProduct"> | string
    handle?: StringFilter<"ProductVariantProduct"> | string
    onlineStoreUrl?: StringFilter<"ProductVariantProduct"> | string
    productVariantId?: StringFilter<"ProductVariantProduct"> | string
    createdAt?: DateTimeFilter<"ProductVariantProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariantProduct"> | Date | string
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }

  export type ProductVariantProductOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    onlineStoreUrl?: SortOrder
    productVariantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productVariant?: ProductVariantOrderByWithRelationInput
  }

  export type ProductVariantProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productVariantId?: string
    AND?: ProductVariantProductWhereInput | ProductVariantProductWhereInput[]
    OR?: ProductVariantProductWhereInput[]
    NOT?: ProductVariantProductWhereInput | ProductVariantProductWhereInput[]
    shopifyId?: StringFilter<"ProductVariantProduct"> | string
    handle?: StringFilter<"ProductVariantProduct"> | string
    onlineStoreUrl?: StringFilter<"ProductVariantProduct"> | string
    createdAt?: DateTimeFilter<"ProductVariantProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariantProduct"> | Date | string
    productVariant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }, "id" | "productVariantId">

  export type ProductVariantProductOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    onlineStoreUrl?: SortOrder
    productVariantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantProductCountOrderByAggregateInput
    _max?: ProductVariantProductMaxOrderByAggregateInput
    _min?: ProductVariantProductMinOrderByAggregateInput
  }

  export type ProductVariantProductScalarWhereWithAggregatesInput = {
    AND?: ProductVariantProductScalarWhereWithAggregatesInput | ProductVariantProductScalarWhereWithAggregatesInput[]
    OR?: ProductVariantProductScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantProductScalarWhereWithAggregatesInput | ProductVariantProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariantProduct"> | string
    shopifyId?: StringWithAggregatesFilter<"ProductVariantProduct"> | string
    handle?: StringWithAggregatesFilter<"ProductVariantProduct"> | string
    onlineStoreUrl?: StringWithAggregatesFilter<"ProductVariantProduct"> | string
    productVariantId?: StringWithAggregatesFilter<"ProductVariantProduct"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariantProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariantProduct"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    shopifyId?: StringFilter<"ProductVariant"> | string
    title?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringNullableFilter<"ProductVariant"> | string | null
    productVariantProductId?: StringNullableFilter<"ProductVariant"> | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    productVariantProduct?: XOR<ProductVariantProductNullableScalarRelationFilter, ProductVariantProductWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    productVariantProductId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productVariantProduct?: ProductVariantProductOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    shopifyId?: StringFilter<"ProductVariant"> | string
    title?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringNullableFilter<"ProductVariant"> | string | null
    productVariantProductId?: StringNullableFilter<"ProductVariant"> | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    productVariantProduct?: XOR<ProductVariantProductNullableScalarRelationFilter, ProductVariantProductWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    productVariantProductId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    shopifyId?: StringWithAggregatesFilter<"ProductVariant"> | string
    title?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    productId?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    productVariantProductId?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    shopifyId?: StringFilter<"Product"> | string
    handle?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    title?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    onlineStoreUrl?: StringFilter<"Product"> | string
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    productSEOId?: StringNullableFilter<"Product"> | string | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    ProductSEO?: XOR<ProductSEONullableScalarRelationFilter, ProductSEOWhereInput> | null
    variants?: ProductVariantListRelationFilter
    featuredMedia?: XOR<ProductFeaturedMediaNullableScalarRelationFilter, ProductFeaturedMediaWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    tags?: SortOrder
    onlineStoreUrl?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productSEOId?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    ProductSEO?: ProductSEOOrderByWithRelationInput
    variants?: ProductVariantOrderByRelationAggregateInput
    featuredMedia?: ProductFeaturedMediaOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    shopifyId?: StringFilter<"Product"> | string
    handle?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    title?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    onlineStoreUrl?: StringFilter<"Product"> | string
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    productSEOId?: StringNullableFilter<"Product"> | string | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    ProductSEO?: XOR<ProductSEONullableScalarRelationFilter, ProductSEOWhereInput> | null
    variants?: ProductVariantListRelationFilter
    featuredMedia?: XOR<ProductFeaturedMediaNullableScalarRelationFilter, ProductFeaturedMediaWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    tags?: SortOrder
    onlineStoreUrl?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productSEOId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    shopifyId?: StringWithAggregatesFilter<"Product"> | string
    handle?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    title?: StringNullableWithAggregatesFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    onlineStoreUrl?: StringWithAggregatesFilter<"Product"> | string
    shopId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    productSEOId?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type OrderPriceWhereInput = {
    AND?: OrderPriceWhereInput | OrderPriceWhereInput[]
    OR?: OrderPriceWhereInput[]
    NOT?: OrderPriceWhereInput | OrderPriceWhereInput[]
    id?: StringFilter<"OrderPrice"> | string
    amount?: DecimalFilter<"OrderPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFilter<"OrderPrice"> | string
    orderId?: StringFilter<"OrderPrice"> | string
    createdAt?: DateTimeFilter<"OrderPrice"> | Date | string
    updatedAt?: DateTimeFilter<"OrderPrice"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderPriceOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: OrderPriceWhereInput | OrderPriceWhereInput[]
    OR?: OrderPriceWhereInput[]
    NOT?: OrderPriceWhereInput | OrderPriceWhereInput[]
    amount?: DecimalFilter<"OrderPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFilter<"OrderPrice"> | string
    createdAt?: DateTimeFilter<"OrderPrice"> | Date | string
    updatedAt?: DateTimeFilter<"OrderPrice"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type OrderPriceOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderPriceCountOrderByAggregateInput
    _avg?: OrderPriceAvgOrderByAggregateInput
    _max?: OrderPriceMaxOrderByAggregateInput
    _min?: OrderPriceMinOrderByAggregateInput
    _sum?: OrderPriceSumOrderByAggregateInput
  }

  export type OrderPriceScalarWhereWithAggregatesInput = {
    AND?: OrderPriceScalarWhereWithAggregatesInput | OrderPriceScalarWhereWithAggregatesInput[]
    OR?: OrderPriceScalarWhereWithAggregatesInput[]
    NOT?: OrderPriceScalarWhereWithAggregatesInput | OrderPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderPrice"> | string
    amount?: DecimalWithAggregatesFilter<"OrderPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: StringWithAggregatesFilter<"OrderPrice"> | string
    orderId?: StringWithAggregatesFilter<"OrderPrice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderPrice"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringFilter<"Order"> | string
    shopifyId?: StringFilter<"Order"> | string
    unpaid?: BoolFilter<"Order"> | boolean
    processedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderPriceId?: StringNullableFilter<"Order"> | string | null
    shopId?: StringNullableFilter<"Order"> | string | null
    orderPrice?: XOR<OrderPriceNullableScalarRelationFilter, OrderPriceWhereInput> | null
    Shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shopifyId?: SortOrder
    unpaid?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderPriceId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    orderPrice?: OrderPriceOrderByWithRelationInput
    Shop?: ShopOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    name?: StringFilter<"Order"> | string
    shopifyId?: StringFilter<"Order"> | string
    unpaid?: BoolFilter<"Order"> | boolean
    processedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderPriceId?: StringNullableFilter<"Order"> | string | null
    shopId?: StringNullableFilter<"Order"> | string | null
    orderPrice?: XOR<OrderPriceNullableScalarRelationFilter, OrderPriceWhereInput> | null
    Shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shopifyId?: SortOrder
    unpaid?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderPriceId?: SortOrderInput | SortOrder
    shopId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    name?: StringWithAggregatesFilter<"Order"> | string
    shopifyId?: StringWithAggregatesFilter<"Order"> | string
    unpaid?: BoolWithAggregatesFilter<"Order"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    orderPriceId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shopId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type CollectionImageWhereInput = {
    AND?: CollectionImageWhereInput | CollectionImageWhereInput[]
    OR?: CollectionImageWhereInput[]
    NOT?: CollectionImageWhereInput | CollectionImageWhereInput[]
    id?: StringFilter<"CollectionImage"> | string
    url?: StringNullableFilter<"CollectionImage"> | string | null
    collectionId?: StringFilter<"CollectionImage"> | string
    createdAt?: DateTimeFilter<"CollectionImage"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionImage"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
  }

  export type CollectionImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    collectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collection?: CollectionOrderByWithRelationInput
  }

  export type CollectionImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collectionId?: string
    AND?: CollectionImageWhereInput | CollectionImageWhereInput[]
    OR?: CollectionImageWhereInput[]
    NOT?: CollectionImageWhereInput | CollectionImageWhereInput[]
    url?: StringNullableFilter<"CollectionImage"> | string | null
    createdAt?: DateTimeFilter<"CollectionImage"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionImage"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
  }, "id" | "collectionId">

  export type CollectionImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    collectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionImageCountOrderByAggregateInput
    _max?: CollectionImageMaxOrderByAggregateInput
    _min?: CollectionImageMinOrderByAggregateInput
  }

  export type CollectionImageScalarWhereWithAggregatesInput = {
    AND?: CollectionImageScalarWhereWithAggregatesInput | CollectionImageScalarWhereWithAggregatesInput[]
    OR?: CollectionImageScalarWhereWithAggregatesInput[]
    NOT?: CollectionImageScalarWhereWithAggregatesInput | CollectionImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionImage"> | string
    url?: StringNullableWithAggregatesFilter<"CollectionImage"> | string | null
    collectionId?: StringWithAggregatesFilter<"CollectionImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CollectionImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionImage"> | Date | string
  }

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    id?: StringFilter<"Collection"> | string
    shopifyId?: StringFilter<"Collection"> | string
    title?: StringNullableFilter<"Collection"> | string | null
    description?: StringNullableFilter<"Collection"> | string | null
    handle?: StringFilter<"Collection"> | string
    collectionImageId?: StringNullableFilter<"Collection"> | string | null
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
    shopId?: StringNullableFilter<"Collection"> | string | null
    collectionImage?: XOR<CollectionImageNullableScalarRelationFilter, CollectionImageWhereInput> | null
    Shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    handle?: SortOrder
    collectionImageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrderInput | SortOrder
    collectionImage?: CollectionImageOrderByWithRelationInput
    Shop?: ShopOrderByWithRelationInput
  }

  export type CollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    shopifyId?: StringFilter<"Collection"> | string
    title?: StringNullableFilter<"Collection"> | string | null
    description?: StringNullableFilter<"Collection"> | string | null
    handle?: StringFilter<"Collection"> | string
    collectionImageId?: StringNullableFilter<"Collection"> | string | null
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
    shopId?: StringNullableFilter<"Collection"> | string | null
    collectionImage?: XOR<CollectionImageNullableScalarRelationFilter, CollectionImageWhereInput> | null
    Shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }, "id">

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    handle?: SortOrder
    collectionImageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrderInput | SortOrder
    _count?: CollectionCountOrderByAggregateInput
    _max?: CollectionMaxOrderByAggregateInput
    _min?: CollectionMinOrderByAggregateInput
  }

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    OR?: CollectionScalarWhereWithAggregatesInput[]
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Collection"> | string
    shopifyId?: StringWithAggregatesFilter<"Collection"> | string
    title?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    description?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    handle?: StringWithAggregatesFilter<"Collection"> | string
    collectionImageId?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    shopId?: StringNullableWithAggregatesFilter<"Collection"> | string | null
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: StringFilter<"Shop"> | string
    shopifyId?: StringFilter<"Shop"> | string
    myshopifyDomain?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    shipsToCountries?: StringNullableListFilter<"Shop">
    accessToken?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    userId?: StringNullableFilter<"Shop"> | string | null
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    collections?: CollectionListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    myshopifyDomain?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shipsToCountries?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    collections?: CollectionOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    shopifyId?: StringFilter<"Shop"> | string
    myshopifyDomain?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    shipsToCountries?: StringNullableListFilter<"Shop">
    accessToken?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    userId?: StringNullableFilter<"Shop"> | string | null
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    collections?: CollectionListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    myshopifyDomain?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shipsToCountries?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ShopCountOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shop"> | string
    shopifyId?: StringWithAggregatesFilter<"Shop"> | string
    myshopifyDomain?: StringWithAggregatesFilter<"Shop"> | string
    name?: StringWithAggregatesFilter<"Shop"> | string
    description?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    shipsToCountries?: StringNullableListFilter<"Shop">
    accessToken?: StringWithAggregatesFilter<"Shop"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Shop"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    shops?: ShopListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    shops?: ShopOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    shops?: ShopListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type FeaturedMediaVideoCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productFeaturedMedia: ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaVideoInput
  }

  export type FeaturedMediaVideoUncheckedCreateInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFeaturedMedia?: ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaVideoNestedInput
  }

  export type FeaturedMediaVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaVideoCreateManyInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaExternalVideoCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productFeaturedMedia: ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaExternalVideoInput
  }

  export type FeaturedMediaExternalVideoUncheckedCreateInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaExternalVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFeaturedMedia?: ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaExternalVideoNestedInput
  }

  export type FeaturedMediaExternalVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaExternalVideoCreateManyInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaExternalVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaExternalVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaImageCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productFeaturedMedia: ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaImageInput
  }

  export type FeaturedMediaImageUncheckedCreateInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFeaturedMedia?: ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaImageNestedInput
  }

  export type FeaturedMediaImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaImageCreateManyInput = {
    id?: string
    url: string
    productFeaturedMediaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    productFeaturedMediaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFeaturedMediaCreateInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageCreateNestedOneWithoutProductFeaturedMediaInput
    Product: ProductCreateNestedOneWithoutFeaturedMediaInput
  }

  export type ProductFeaturedMediaUncheckedCreateInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUpdateOneWithoutProductFeaturedMediaNestedInput
    Product?: ProductUpdateOneRequiredWithoutFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaCreateManyInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
  }

  export type ProductFeaturedMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductFeaturedMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductSEOCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutProductSEOInput
  }

  export type ProductSEOUncheckedCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSEOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutProductSEONestedInput
  }

  export type ProductSEOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSEOCreateManyInput = {
    id?: string
    title?: string | null
    description?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSEOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSEOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantProductCreateInput = {
    id?: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariant: ProductVariantCreateNestedOneWithoutProductVariantProductInput
  }

  export type ProductVariantProductUncheckedCreateInput = {
    id?: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    productVariantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariant?: ProductVariantUpdateOneRequiredWithoutProductVariantProductNestedInput
  }

  export type ProductVariantProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantProductCreateManyInput = {
    id?: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    productVariantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    productVariantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariantProduct?: ProductVariantProductCreateNestedOneWithoutProductVariantInput
    product?: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productId?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariantProduct?: ProductVariantProductUncheckedCreateNestedOneWithoutProductVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariantProduct?: ProductVariantProductUpdateOneWithoutProductVariantNestedInput
    product?: ProductUpdateOneWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariantProduct?: ProductVariantProductUncheckedUpdateOneWithoutProductVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productId?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    shop?: ShopCreateNestedOneWithoutProductsInput
    ProductSEO?: ProductSEOCreateNestedOneWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    ProductSEO?: ProductSEOUncheckedCreateNestedOneWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneWithoutProductsNestedInput
    ProductSEO?: ProductSEOUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductSEO?: ProductSEOUncheckedUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPriceCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    currencyCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderPriceInput
  }

  export type OrderPriceUncheckedCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    currencyCode?: string
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderPriceNestedInput
  }

  export type OrderPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPriceCreateManyInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    currencyCode?: string
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    orderPrice?: OrderPriceCreateNestedOneWithoutOrderInput
    Shop?: ShopCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    shopId?: string | null
    orderPrice?: OrderPriceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPrice?: OrderPriceUpdateOneWithoutOrderNestedInput
    Shop?: ShopUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPrice?: OrderPriceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    shopId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionImageCreateInput = {
    id?: string
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: CollectionCreateNestedOneWithoutCollectionImageInput
  }

  export type CollectionImageUncheckedCreateInput = {
    id?: string
    url?: string | null
    collectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneRequiredWithoutCollectionImageNestedInput
  }

  export type CollectionImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionImageCreateManyInput = {
    id?: string
    url?: string | null
    collectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCreateInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionImage?: CollectionImageCreateNestedOneWithoutCollectionInput
    Shop?: ShopCreateNestedOneWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shopId?: string | null
    collectionImage?: CollectionImageUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionImage?: CollectionImageUpdateOneWithoutCollectionNestedInput
    Shop?: ShopUpdateOneWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionImage?: CollectionImageUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionCreateManyInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shopId?: string | null
  }

  export type CollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShopCreateInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutShopInput
    orders?: OrderCreateNestedManyWithoutShopInput
    collections?: CollectionCreateNestedManyWithoutShopInput
    User?: UserCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    orders?: OrderUncheckedCreateNestedManyWithoutShopInput
    collections?: CollectionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutShopNestedInput
    orders?: OrderUpdateManyWithoutShopNestedInput
    collections?: CollectionUpdateManyWithoutShopNestedInput
    User?: UserUpdateOneWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutShopNestedInput
    orders?: OrderUncheckedUpdateManyWithoutShopNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type ShopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    shops?: ShopCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductFeaturedMediaScalarRelationFilter = {
    is?: ProductFeaturedMediaWhereInput
    isNot?: ProductFeaturedMediaWhereInput
  }

  export type FeaturedMediaVideoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaVideoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FeaturedMediaExternalVideoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaExternalVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaExternalVideoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedMediaImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productFeaturedMediaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumMediaContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaContentType | EnumMediaContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaContentTypeFilter<$PrismaModel> | $Enums.MediaContentType
  }

  export type FeaturedMediaVideoNullableScalarRelationFilter = {
    is?: FeaturedMediaVideoWhereInput | null
    isNot?: FeaturedMediaVideoWhereInput | null
  }

  export type FeaturedMediaExternalVideoNullableScalarRelationFilter = {
    is?: FeaturedMediaExternalVideoWhereInput | null
    isNot?: FeaturedMediaExternalVideoWhereInput | null
  }

  export type FeaturedMediaImageNullableScalarRelationFilter = {
    is?: FeaturedMediaImageWhereInput | null
    isNot?: FeaturedMediaImageWhereInput | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductFeaturedMediaCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    alt?: SortOrder
    mediaContentType?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featuredMediaVideoId?: SortOrder
    featuredMediaExternalVideoId?: SortOrder
    featuredMediaImageId?: SortOrder
  }

  export type ProductFeaturedMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    alt?: SortOrder
    mediaContentType?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featuredMediaVideoId?: SortOrder
    featuredMediaExternalVideoId?: SortOrder
    featuredMediaImageId?: SortOrder
  }

  export type ProductFeaturedMediaMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    alt?: SortOrder
    mediaContentType?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featuredMediaVideoId?: SortOrder
    featuredMediaExternalVideoId?: SortOrder
    featuredMediaImageId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumMediaContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaContentType | EnumMediaContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaContentTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaContentTypeFilter<$PrismaModel>
  }

  export type ProductSEOCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSEOMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSEOMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type ProductVariantProductCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    onlineStoreUrl?: SortOrder
    productVariantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantProductMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    onlineStoreUrl?: SortOrder
    productVariantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantProductMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    onlineStoreUrl?: SortOrder
    productVariantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantProductNullableScalarRelationFilter = {
    is?: ProductVariantProductWhereInput | null
    isNot?: ProductVariantProductWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    productId?: SortOrder
    productVariantProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    productId?: SortOrder
    productVariantProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    productId?: SortOrder
    productVariantProductId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ShopNullableScalarRelationFilter = {
    is?: ShopWhereInput | null
    isNot?: ShopWhereInput | null
  }

  export type ProductSEONullableScalarRelationFilter = {
    is?: ProductSEOWhereInput | null
    isNot?: ProductSEOWhereInput | null
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductFeaturedMediaNullableScalarRelationFilter = {
    is?: ProductFeaturedMediaWhereInput | null
    isNot?: ProductFeaturedMediaWhereInput | null
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    description?: SortOrder
    title?: SortOrder
    tags?: SortOrder
    onlineStoreUrl?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productSEOId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    description?: SortOrder
    title?: SortOrder
    onlineStoreUrl?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productSEOId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    handle?: SortOrder
    description?: SortOrder
    title?: SortOrder
    onlineStoreUrl?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productSEOId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderPriceCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderPriceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderPriceMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderPriceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrderPriceNullableScalarRelationFilter = {
    is?: OrderPriceWhereInput | null
    isNot?: OrderPriceWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopifyId?: SortOrder
    unpaid?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderPriceId?: SortOrder
    shopId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopifyId?: SortOrder
    unpaid?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderPriceId?: SortOrder
    shopId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shopifyId?: SortOrder
    unpaid?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderPriceId?: SortOrder
    shopId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CollectionScalarRelationFilter = {
    is?: CollectionWhereInput
    isNot?: CollectionWhereInput
  }

  export type CollectionImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionImageNullableScalarRelationFilter = {
    is?: CollectionImageWhereInput | null
    isNot?: CollectionImageWhereInput | null
  }

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    handle?: SortOrder
    collectionImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
  }

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    handle?: SortOrder
    collectionImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
  }

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    handle?: SortOrder
    collectionImageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CollectionListRelationFilter = {
    every?: CollectionWhereInput
    some?: CollectionWhereInput
    none?: CollectionWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    myshopifyDomain?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shipsToCountries?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    myshopifyDomain?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyId?: SortOrder
    myshopifyDomain?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaVideoInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaVideoInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaVideoInput
    connect?: ProductFeaturedMediaWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaVideoNestedInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaVideoInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaVideoInput
    upsert?: ProductFeaturedMediaUpsertWithoutFeaturedMediaVideoInput
    connect?: ProductFeaturedMediaWhereUniqueInput
    update?: XOR<XOR<ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUpdateWithoutFeaturedMediaVideoInput>, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaVideoInput>
  }

  export type ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaExternalVideoInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaExternalVideoInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaExternalVideoInput
    connect?: ProductFeaturedMediaWhereUniqueInput
  }

  export type ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaExternalVideoNestedInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaExternalVideoInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaExternalVideoInput
    upsert?: ProductFeaturedMediaUpsertWithoutFeaturedMediaExternalVideoInput
    connect?: ProductFeaturedMediaWhereUniqueInput
    update?: XOR<XOR<ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUpdateWithoutFeaturedMediaExternalVideoInput>, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaExternalVideoInput>
  }

  export type ProductFeaturedMediaCreateNestedOneWithoutFeaturedMediaImageInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaImageInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaImageInput
    connect?: ProductFeaturedMediaWhereUniqueInput
  }

  export type ProductFeaturedMediaUpdateOneRequiredWithoutFeaturedMediaImageNestedInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaImageInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaImageInput
    upsert?: ProductFeaturedMediaUpsertWithoutFeaturedMediaImageInput
    connect?: ProductFeaturedMediaWhereUniqueInput
    update?: XOR<XOR<ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaImageInput, ProductFeaturedMediaUpdateWithoutFeaturedMediaImageInput>, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaImageInput>
  }

  export type FeaturedMediaVideoCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaVideoCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaVideoWhereUniqueInput
  }

  export type FeaturedMediaExternalVideoCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaExternalVideoCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaExternalVideoWhereUniqueInput
  }

  export type FeaturedMediaImageCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaImageCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaImageWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutFeaturedMediaInput = {
    create?: XOR<ProductCreateWithoutFeaturedMediaInput, ProductUncheckedCreateWithoutFeaturedMediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFeaturedMediaInput
    connect?: ProductWhereUniqueInput
  }

  export type FeaturedMediaVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaVideoCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaVideoWhereUniqueInput
  }

  export type FeaturedMediaExternalVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaExternalVideoCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaExternalVideoWhereUniqueInput
  }

  export type FeaturedMediaImageUncheckedCreateNestedOneWithoutProductFeaturedMediaInput = {
    create?: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaImageCreateOrConnectWithoutProductFeaturedMediaInput
    connect?: FeaturedMediaImageWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumMediaContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaContentType
  }

  export type FeaturedMediaVideoUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaVideoCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaVideoUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaVideoWhereInput | boolean
    delete?: FeaturedMediaVideoWhereInput | boolean
    connect?: FeaturedMediaVideoWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaVideoUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaExternalVideoUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaExternalVideoCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaExternalVideoUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaExternalVideoWhereInput | boolean
    delete?: FeaturedMediaExternalVideoWhereInput | boolean
    connect?: FeaturedMediaExternalVideoWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaExternalVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaExternalVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaImageUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaImageCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaImageUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaImageWhereInput | boolean
    delete?: FeaturedMediaImageWhereInput | boolean
    connect?: FeaturedMediaImageWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaImageUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaImageUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaImageUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type ProductUpdateOneRequiredWithoutFeaturedMediaNestedInput = {
    create?: XOR<ProductCreateWithoutFeaturedMediaInput, ProductUncheckedCreateWithoutFeaturedMediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFeaturedMediaInput
    upsert?: ProductUpsertWithoutFeaturedMediaInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFeaturedMediaInput, ProductUpdateWithoutFeaturedMediaInput>, ProductUncheckedUpdateWithoutFeaturedMediaInput>
  }

  export type FeaturedMediaVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaVideoCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaVideoUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaVideoWhereInput | boolean
    delete?: FeaturedMediaVideoWhereInput | boolean
    connect?: FeaturedMediaVideoWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaVideoUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaExternalVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaExternalVideoCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaExternalVideoUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaExternalVideoWhereInput | boolean
    delete?: FeaturedMediaExternalVideoWhereInput | boolean
    connect?: FeaturedMediaExternalVideoWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaExternalVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaExternalVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaImageUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput = {
    create?: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
    connectOrCreate?: FeaturedMediaImageCreateOrConnectWithoutProductFeaturedMediaInput
    upsert?: FeaturedMediaImageUpsertWithoutProductFeaturedMediaInput
    disconnect?: FeaturedMediaImageWhereInput | boolean
    delete?: FeaturedMediaImageWhereInput | boolean
    connect?: FeaturedMediaImageWhereUniqueInput
    update?: XOR<XOR<FeaturedMediaImageUpdateToOneWithWhereWithoutProductFeaturedMediaInput, FeaturedMediaImageUpdateWithoutProductFeaturedMediaInput>, FeaturedMediaImageUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type ProductCreateNestedOneWithoutProductSEOInput = {
    create?: XOR<ProductCreateWithoutProductSEOInput, ProductUncheckedCreateWithoutProductSEOInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductSEOInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductSEONestedInput = {
    create?: XOR<ProductCreateWithoutProductSEOInput, ProductUncheckedCreateWithoutProductSEOInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductSEOInput
    upsert?: ProductUpsertWithoutProductSEOInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductSEOInput, ProductUpdateWithoutProductSEOInput>, ProductUncheckedUpdateWithoutProductSEOInput>
  }

  export type ProductVariantCreateNestedOneWithoutProductVariantProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductVariantProductInput, ProductVariantUncheckedCreateWithoutProductVariantProductInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductVariantProductInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ProductVariantUpdateOneRequiredWithoutProductVariantProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductVariantProductInput, ProductVariantUncheckedCreateWithoutProductVariantProductInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductVariantProductInput
    upsert?: ProductVariantUpsertWithoutProductVariantProductInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutProductVariantProductInput, ProductVariantUpdateWithoutProductVariantProductInput>, ProductVariantUncheckedUpdateWithoutProductVariantProductInput>
  }

  export type ProductVariantProductCreateNestedOneWithoutProductVariantInput = {
    create?: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductVariantProductCreateOrConnectWithoutProductVariantInput
    connect?: ProductVariantProductWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariantProductUncheckedCreateNestedOneWithoutProductVariantInput = {
    create?: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductVariantProductCreateOrConnectWithoutProductVariantInput
    connect?: ProductVariantProductWhereUniqueInput
  }

  export type ProductVariantProductUpdateOneWithoutProductVariantNestedInput = {
    create?: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductVariantProductCreateOrConnectWithoutProductVariantInput
    upsert?: ProductVariantProductUpsertWithoutProductVariantInput
    disconnect?: ProductVariantProductWhereInput | boolean
    delete?: ProductVariantProductWhereInput | boolean
    connect?: ProductVariantProductWhereUniqueInput
    update?: XOR<XOR<ProductVariantProductUpdateToOneWithWhereWithoutProductVariantInput, ProductVariantProductUpdateWithoutProductVariantInput>, ProductVariantProductUncheckedUpdateWithoutProductVariantInput>
  }

  export type ProductUpdateOneWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductVariantProductUncheckedUpdateOneWithoutProductVariantNestedInput = {
    create?: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
    connectOrCreate?: ProductVariantProductCreateOrConnectWithoutProductVariantInput
    upsert?: ProductVariantProductUpsertWithoutProductVariantInput
    disconnect?: ProductVariantProductWhereInput | boolean
    delete?: ProductVariantProductWhereInput | boolean
    connect?: ProductVariantProductWhereUniqueInput
    update?: XOR<XOR<ProductVariantProductUpdateToOneWithWhereWithoutProductVariantInput, ProductVariantProductUpdateWithoutProductVariantInput>, ProductVariantProductUncheckedUpdateWithoutProductVariantInput>
  }

  export type ProductCreatetagsInput = {
    set: string[]
  }

  export type ShopCreateNestedOneWithoutProductsInput = {
    create?: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProductsInput
    connect?: ShopWhereUniqueInput
  }

  export type ProductSEOCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSEOCreateOrConnectWithoutProductInput
    connect?: ProductSEOWhereUniqueInput
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductFeaturedMediaCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutProductInput
    connect?: ProductFeaturedMediaWhereUniqueInput
  }

  export type ProductSEOUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSEOCreateOrConnectWithoutProductInput
    connect?: ProductSEOWhereUniqueInput
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductFeaturedMediaUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutProductInput
    connect?: ProductFeaturedMediaWhereUniqueInput
  }

  export type ProductUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShopUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutProductsInput
    upsert?: ShopUpsertWithoutProductsInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutProductsInput, ShopUpdateWithoutProductsInput>, ShopUncheckedUpdateWithoutProductsInput>
  }

  export type ProductSEOUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSEOCreateOrConnectWithoutProductInput
    upsert?: ProductSEOUpsertWithoutProductInput
    disconnect?: ProductSEOWhereInput | boolean
    delete?: ProductSEOWhereInput | boolean
    connect?: ProductSEOWhereUniqueInput
    update?: XOR<XOR<ProductSEOUpdateToOneWithWhereWithoutProductInput, ProductSEOUpdateWithoutProductInput>, ProductSEOUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductFeaturedMediaUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutProductInput
    upsert?: ProductFeaturedMediaUpsertWithoutProductInput
    disconnect?: ProductFeaturedMediaWhereInput | boolean
    delete?: ProductFeaturedMediaWhereInput | boolean
    connect?: ProductFeaturedMediaWhereUniqueInput
    update?: XOR<XOR<ProductFeaturedMediaUpdateToOneWithWhereWithoutProductInput, ProductFeaturedMediaUpdateWithoutProductInput>, ProductFeaturedMediaUncheckedUpdateWithoutProductInput>
  }

  export type ProductSEOUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSEOCreateOrConnectWithoutProductInput
    upsert?: ProductSEOUpsertWithoutProductInput
    disconnect?: ProductSEOWhereInput | boolean
    delete?: ProductSEOWhereInput | boolean
    connect?: ProductSEOWhereUniqueInput
    update?: XOR<XOR<ProductSEOUpdateToOneWithWhereWithoutProductInput, ProductSEOUpdateWithoutProductInput>, ProductSEOUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductFeaturedMediaUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFeaturedMediaCreateOrConnectWithoutProductInput
    upsert?: ProductFeaturedMediaUpsertWithoutProductInput
    disconnect?: ProductFeaturedMediaWhereInput | boolean
    delete?: ProductFeaturedMediaWhereInput | boolean
    connect?: ProductFeaturedMediaWhereUniqueInput
    update?: XOR<XOR<ProductFeaturedMediaUpdateToOneWithWhereWithoutProductInput, ProductFeaturedMediaUpdateWithoutProductInput>, ProductFeaturedMediaUncheckedUpdateWithoutProductInput>
  }

  export type OrderCreateNestedOneWithoutOrderPriceInput = {
    create?: XOR<OrderCreateWithoutOrderPriceInput, OrderUncheckedCreateWithoutOrderPriceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderPriceInput
    connect?: OrderWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrderUpdateOneRequiredWithoutOrderPriceNestedInput = {
    create?: XOR<OrderCreateWithoutOrderPriceInput, OrderUncheckedCreateWithoutOrderPriceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderPriceInput
    upsert?: OrderUpsertWithoutOrderPriceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderPriceInput, OrderUpdateWithoutOrderPriceInput>, OrderUncheckedUpdateWithoutOrderPriceInput>
  }

  export type OrderPriceCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderPriceCreateOrConnectWithoutOrderInput
    connect?: OrderPriceWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrdersInput
    connect?: ShopWhereUniqueInput
  }

  export type OrderPriceUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderPriceCreateOrConnectWithoutOrderInput
    connect?: OrderPriceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrderPriceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderPriceCreateOrConnectWithoutOrderInput
    upsert?: OrderPriceUpsertWithoutOrderInput
    disconnect?: OrderPriceWhereInput | boolean
    delete?: OrderPriceWhereInput | boolean
    connect?: OrderPriceWhereUniqueInput
    update?: XOR<XOR<OrderPriceUpdateToOneWithWhereWithoutOrderInput, OrderPriceUpdateWithoutOrderInput>, OrderPriceUncheckedUpdateWithoutOrderInput>
  }

  export type ShopUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrdersInput
    upsert?: ShopUpsertWithoutOrdersInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutOrdersInput, ShopUpdateWithoutOrdersInput>, ShopUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderPriceUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderPriceCreateOrConnectWithoutOrderInput
    upsert?: OrderPriceUpsertWithoutOrderInput
    disconnect?: OrderPriceWhereInput | boolean
    delete?: OrderPriceWhereInput | boolean
    connect?: OrderPriceWhereUniqueInput
    update?: XOR<XOR<OrderPriceUpdateToOneWithWhereWithoutOrderInput, OrderPriceUpdateWithoutOrderInput>, OrderPriceUncheckedUpdateWithoutOrderInput>
  }

  export type CollectionCreateNestedOneWithoutCollectionImageInput = {
    create?: XOR<CollectionCreateWithoutCollectionImageInput, CollectionUncheckedCreateWithoutCollectionImageInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutCollectionImageInput
    connect?: CollectionWhereUniqueInput
  }

  export type CollectionUpdateOneRequiredWithoutCollectionImageNestedInput = {
    create?: XOR<CollectionCreateWithoutCollectionImageInput, CollectionUncheckedCreateWithoutCollectionImageInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutCollectionImageInput
    upsert?: CollectionUpsertWithoutCollectionImageInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutCollectionImageInput, CollectionUpdateWithoutCollectionImageInput>, CollectionUncheckedUpdateWithoutCollectionImageInput>
  }

  export type CollectionImageCreateNestedOneWithoutCollectionInput = {
    create?: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: CollectionImageCreateOrConnectWithoutCollectionInput
    connect?: CollectionImageWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<ShopCreateWithoutCollectionsInput, ShopUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCollectionsInput
    connect?: ShopWhereUniqueInput
  }

  export type CollectionImageUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: CollectionImageCreateOrConnectWithoutCollectionInput
    connect?: CollectionImageWhereUniqueInput
  }

  export type CollectionImageUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: CollectionImageCreateOrConnectWithoutCollectionInput
    upsert?: CollectionImageUpsertWithoutCollectionInput
    disconnect?: CollectionImageWhereInput | boolean
    delete?: CollectionImageWhereInput | boolean
    connect?: CollectionImageWhereUniqueInput
    update?: XOR<XOR<CollectionImageUpdateToOneWithWhereWithoutCollectionInput, CollectionImageUpdateWithoutCollectionInput>, CollectionImageUncheckedUpdateWithoutCollectionInput>
  }

  export type ShopUpdateOneWithoutCollectionsNestedInput = {
    create?: XOR<ShopCreateWithoutCollectionsInput, ShopUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCollectionsInput
    upsert?: ShopUpsertWithoutCollectionsInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutCollectionsInput, ShopUpdateWithoutCollectionsInput>, ShopUncheckedUpdateWithoutCollectionsInput>
  }

  export type CollectionImageUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: CollectionImageCreateOrConnectWithoutCollectionInput
    upsert?: CollectionImageUpsertWithoutCollectionInput
    disconnect?: CollectionImageWhereInput | boolean
    delete?: CollectionImageWhereInput | boolean
    connect?: CollectionImageWhereUniqueInput
    update?: XOR<XOR<CollectionImageUpdateToOneWithWhereWithoutCollectionInput, CollectionImageUpdateWithoutCollectionInput>, CollectionImageUncheckedUpdateWithoutCollectionInput>
  }

  export type ShopCreateshipsToCountriesInput = {
    set: string[]
  }

  export type ProductCreateNestedManyWithoutShopInput = {
    create?: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput> | ProductCreateWithoutShopInput[] | ProductUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutShopInput | ProductCreateOrConnectWithoutShopInput[]
    createMany?: ProductCreateManyShopInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CollectionCreateNestedManyWithoutShopInput = {
    create?: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput> | CollectionCreateWithoutShopInput[] | CollectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutShopInput | CollectionCreateOrConnectWithoutShopInput[]
    createMany?: CollectionCreateManyShopInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutShopsInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput> | ProductCreateWithoutShopInput[] | ProductUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutShopInput | ProductCreateOrConnectWithoutShopInput[]
    createMany?: ProductCreateManyShopInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput> | CollectionCreateWithoutShopInput[] | CollectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutShopInput | CollectionCreateOrConnectWithoutShopInput[]
    createMany?: CollectionCreateManyShopInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type ShopUpdateshipsToCountriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductUpdateManyWithoutShopNestedInput = {
    create?: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput> | ProductCreateWithoutShopInput[] | ProductUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutShopInput | ProductCreateOrConnectWithoutShopInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutShopInput | ProductUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ProductCreateManyShopInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutShopInput | ProductUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutShopInput | ProductUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShopInput | OrderUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShopInput | OrderUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShopInput | OrderUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CollectionUpdateManyWithoutShopNestedInput = {
    create?: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput> | CollectionCreateWithoutShopInput[] | CollectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutShopInput | CollectionCreateOrConnectWithoutShopInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutShopInput | CollectionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CollectionCreateManyShopInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutShopInput | CollectionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutShopInput | CollectionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutShopsNestedInput = {
    create?: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopsInput
    upsert?: UserUpsertWithoutShopsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShopsInput, UserUpdateWithoutShopsInput>, UserUncheckedUpdateWithoutShopsInput>
  }

  export type ProductUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput> | ProductCreateWithoutShopInput[] | ProductUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutShopInput | ProductCreateOrConnectWithoutShopInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutShopInput | ProductUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ProductCreateManyShopInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutShopInput | ProductUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutShopInput | ProductUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShopInput | OrderUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShopInput | OrderUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShopInput | OrderUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput> | CollectionCreateWithoutShopInput[] | CollectionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutShopInput | CollectionCreateOrConnectWithoutShopInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutShopInput | CollectionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CollectionCreateManyShopInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutShopInput | CollectionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutShopInput | CollectionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ShopCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    createMany?: ShopCreateManyUserInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    createMany?: ShopCreateManyUserInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ShopUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutUserInput | ShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopCreateManyUserInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutUserInput | ShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutUserInput | ShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput> | ShopCreateWithoutUserInput[] | ShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutUserInput | ShopCreateOrConnectWithoutUserInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutUserInput | ShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopCreateManyUserInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutUserInput | ShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutUserInput | ShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumMediaContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaContentType | EnumMediaContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaContentTypeFilter<$PrismaModel> | $Enums.MediaContentType
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMediaContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaContentType | EnumMediaContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaContentType[] | ListEnumMediaContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaContentTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaContentTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProductFeaturedMediaCreateWithoutFeaturedMediaVideoInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageCreateNestedOneWithoutProductFeaturedMediaInput
    Product: ProductCreateNestedOneWithoutFeaturedMediaInput
  }

  export type ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaVideoInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaVideoInput = {
    where: ProductFeaturedMediaWhereUniqueInput
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaVideoInput>
  }

  export type ProductFeaturedMediaUpsertWithoutFeaturedMediaVideoInput = {
    update: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaVideoInput>
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaVideoInput>
    where?: ProductFeaturedMediaWhereInput
  }

  export type ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaVideoInput = {
    where?: ProductFeaturedMediaWhereInput
    data: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaVideoInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaVideoInput>
  }

  export type ProductFeaturedMediaUpdateWithoutFeaturedMediaVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUpdateOneWithoutProductFeaturedMediaNestedInput
    Product?: ProductUpdateOneRequiredWithoutFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaCreateWithoutFeaturedMediaExternalVideoInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageCreateNestedOneWithoutProductFeaturedMediaInput
    Product: ProductCreateNestedOneWithoutFeaturedMediaInput
  }

  export type ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaExternalVideoInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaExternalVideoInput = {
    where: ProductFeaturedMediaWhereUniqueInput
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaExternalVideoInput>
  }

  export type ProductFeaturedMediaUpsertWithoutFeaturedMediaExternalVideoInput = {
    update: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaExternalVideoInput>
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaExternalVideoInput>
    where?: ProductFeaturedMediaWhereInput
  }

  export type ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaExternalVideoInput = {
    where?: ProductFeaturedMediaWhereInput
    data: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaExternalVideoInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaExternalVideoInput>
  }

  export type ProductFeaturedMediaUpdateWithoutFeaturedMediaExternalVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUpdateOneWithoutProductFeaturedMediaNestedInput
    Product?: ProductUpdateOneRequiredWithoutFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaExternalVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaCreateWithoutFeaturedMediaImageInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoCreateNestedOneWithoutProductFeaturedMediaInput
    Product: ProductCreateNestedOneWithoutFeaturedMediaInput
  }

  export type ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaImageInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaCreateOrConnectWithoutFeaturedMediaImageInput = {
    where: ProductFeaturedMediaWhereUniqueInput
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaImageInput>
  }

  export type ProductFeaturedMediaUpsertWithoutFeaturedMediaImageInput = {
    update: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaImageInput>
    create: XOR<ProductFeaturedMediaCreateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedCreateWithoutFeaturedMediaImageInput>
    where?: ProductFeaturedMediaWhereInput
  }

  export type ProductFeaturedMediaUpdateToOneWithWhereWithoutFeaturedMediaImageInput = {
    where?: ProductFeaturedMediaWhereInput
    data: XOR<ProductFeaturedMediaUpdateWithoutFeaturedMediaImageInput, ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaImageInput>
  }

  export type ProductFeaturedMediaUpdateWithoutFeaturedMediaImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    Product?: ProductUpdateOneRequiredWithoutFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaUncheckedUpdateWithoutFeaturedMediaImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaVideoCreateOrConnectWithoutProductFeaturedMediaInput = {
    where: FeaturedMediaVideoWhereUniqueInput
    create: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaExternalVideoCreateOrConnectWithoutProductFeaturedMediaInput = {
    where: FeaturedMediaExternalVideoWhereUniqueInput
    create: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaImageCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedMediaImageCreateOrConnectWithoutProductFeaturedMediaInput = {
    where: FeaturedMediaImageWhereUniqueInput
    create: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
  }

  export type ProductCreateWithoutFeaturedMediaInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    shop?: ShopCreateNestedOneWithoutProductsInput
    ProductSEO?: ProductSEOCreateNestedOneWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFeaturedMediaInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    ProductSEO?: ProductSEOUncheckedCreateNestedOneWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFeaturedMediaInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFeaturedMediaInput, ProductUncheckedCreateWithoutFeaturedMediaInput>
  }

  export type FeaturedMediaVideoUpsertWithoutProductFeaturedMediaInput = {
    update: XOR<FeaturedMediaVideoUpdateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
    create: XOR<FeaturedMediaVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    where?: FeaturedMediaVideoWhereInput
  }

  export type FeaturedMediaVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput = {
    where?: FeaturedMediaVideoWhereInput
    data: XOR<FeaturedMediaVideoUpdateWithoutProductFeaturedMediaInput, FeaturedMediaVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaVideoUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaVideoUncheckedUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaExternalVideoUpsertWithoutProductFeaturedMediaInput = {
    update: XOR<FeaturedMediaExternalVideoUpdateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
    create: XOR<FeaturedMediaExternalVideoCreateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedCreateWithoutProductFeaturedMediaInput>
    where?: FeaturedMediaExternalVideoWhereInput
  }

  export type FeaturedMediaExternalVideoUpdateToOneWithWhereWithoutProductFeaturedMediaInput = {
    where?: FeaturedMediaExternalVideoWhereInput
    data: XOR<FeaturedMediaExternalVideoUpdateWithoutProductFeaturedMediaInput, FeaturedMediaExternalVideoUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaExternalVideoUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaExternalVideoUncheckedUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaImageUpsertWithoutProductFeaturedMediaInput = {
    update: XOR<FeaturedMediaImageUpdateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedUpdateWithoutProductFeaturedMediaInput>
    create: XOR<FeaturedMediaImageCreateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedCreateWithoutProductFeaturedMediaInput>
    where?: FeaturedMediaImageWhereInput
  }

  export type FeaturedMediaImageUpdateToOneWithWhereWithoutProductFeaturedMediaInput = {
    where?: FeaturedMediaImageWhereInput
    data: XOR<FeaturedMediaImageUpdateWithoutProductFeaturedMediaInput, FeaturedMediaImageUncheckedUpdateWithoutProductFeaturedMediaInput>
  }

  export type FeaturedMediaImageUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedMediaImageUncheckedUpdateWithoutProductFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutFeaturedMediaInput = {
    update: XOR<ProductUpdateWithoutFeaturedMediaInput, ProductUncheckedUpdateWithoutFeaturedMediaInput>
    create: XOR<ProductCreateWithoutFeaturedMediaInput, ProductUncheckedCreateWithoutFeaturedMediaInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFeaturedMediaInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFeaturedMediaInput, ProductUncheckedUpdateWithoutFeaturedMediaInput>
  }

  export type ProductUpdateWithoutFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneWithoutProductsNestedInput
    ProductSEO?: ProductSEOUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFeaturedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductSEO?: ProductSEOUncheckedUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutProductSEOInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    shop?: ShopCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductSEOInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductSEOInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductSEOInput, ProductUncheckedCreateWithoutProductSEOInput>
  }

  export type ProductUpsertWithoutProductSEOInput = {
    update: XOR<ProductUpdateWithoutProductSEOInput, ProductUncheckedUpdateWithoutProductSEOInput>
    create: XOR<ProductCreateWithoutProductSEOInput, ProductUncheckedCreateWithoutProductSEOInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductSEOInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductSEOInput, ProductUncheckedUpdateWithoutProductSEOInput>
  }

  export type ProductUpdateWithoutProductSEOInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductSEOInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductVariantCreateWithoutProductVariantProductInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateWithoutProductVariantProductInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productId?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantCreateOrConnectWithoutProductVariantProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductVariantProductInput, ProductVariantUncheckedCreateWithoutProductVariantProductInput>
  }

  export type ProductVariantUpsertWithoutProductVariantProductInput = {
    update: XOR<ProductVariantUpdateWithoutProductVariantProductInput, ProductVariantUncheckedUpdateWithoutProductVariantProductInput>
    create: XOR<ProductVariantCreateWithoutProductVariantProductInput, ProductVariantUncheckedCreateWithoutProductVariantProductInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutProductVariantProductInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutProductVariantProductInput, ProductVariantUncheckedUpdateWithoutProductVariantProductInput>
  }

  export type ProductVariantUpdateWithoutProductVariantProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductVariantProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantProductCreateWithoutProductVariantInput = {
    id?: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantProductUncheckedCreateWithoutProductVariantInput = {
    id?: string
    shopifyId: string
    handle: string
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantProductCreateOrConnectWithoutProductVariantInput = {
    where: ProductVariantProductWhereUniqueInput
    create: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    shop?: ShopCreateNestedOneWithoutProductsInput
    ProductSEO?: ProductSEOCreateNestedOneWithoutProductInput
    featuredMedia?: ProductFeaturedMediaCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    ProductSEO?: ProductSEOUncheckedCreateNestedOneWithoutProductInput
    featuredMedia?: ProductFeaturedMediaUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type ProductVariantProductUpsertWithoutProductVariantInput = {
    update: XOR<ProductVariantProductUpdateWithoutProductVariantInput, ProductVariantProductUncheckedUpdateWithoutProductVariantInput>
    create: XOR<ProductVariantProductCreateWithoutProductVariantInput, ProductVariantProductUncheckedCreateWithoutProductVariantInput>
    where?: ProductVariantProductWhereInput
  }

  export type ProductVariantProductUpdateToOneWithWhereWithoutProductVariantInput = {
    where?: ProductVariantProductWhereInput
    data: XOR<ProductVariantProductUpdateWithoutProductVariantInput, ProductVariantProductUncheckedUpdateWithoutProductVariantInput>
  }

  export type ProductVariantProductUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantProductUncheckedUpdateWithoutProductVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneWithoutProductsNestedInput
    ProductSEO?: ProductSEOUpdateOneWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductSEO?: ProductSEOUncheckedUpdateOneWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ShopCreateWithoutProductsInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutShopInput
    collections?: CollectionCreateNestedManyWithoutShopInput
    User?: UserCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutProductsInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutShopInput
    collections?: CollectionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutProductsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
  }

  export type ProductSEOCreateWithoutProductInput = {
    id?: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSEOUncheckedCreateWithoutProductInput = {
    id?: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSEOCreateOrConnectWithoutProductInput = {
    where: ProductSEOWhereUniqueInput
    create: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariantProduct?: ProductVariantProductCreateNestedOneWithoutProductVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productVariantProduct?: ProductVariantProductUncheckedCreateNestedOneWithoutProductVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductFeaturedMediaCreateWithoutProductInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaUncheckedCreateWithoutProductInput = {
    id?: string
    shopifyId: string
    alt?: string | null
    mediaContentType: $Enums.MediaContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredMediaVideoId?: string | null
    featuredMediaExternalVideoId?: string | null
    featuredMediaImageId?: string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
    featuredMediaImage?: FeaturedMediaImageUncheckedCreateNestedOneWithoutProductFeaturedMediaInput
  }

  export type ProductFeaturedMediaCreateOrConnectWithoutProductInput = {
    where: ProductFeaturedMediaWhereUniqueInput
    create: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
  }

  export type ShopUpsertWithoutProductsInput = {
    update: XOR<ShopUpdateWithoutProductsInput, ShopUncheckedUpdateWithoutProductsInput>
    create: XOR<ShopCreateWithoutProductsInput, ShopUncheckedCreateWithoutProductsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutProductsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutProductsInput, ShopUncheckedUpdateWithoutProductsInput>
  }

  export type ShopUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutShopNestedInput
    collections?: CollectionUpdateManyWithoutShopNestedInput
    User?: UserUpdateOneWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutShopNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ProductSEOUpsertWithoutProductInput = {
    update: XOR<ProductSEOUpdateWithoutProductInput, ProductSEOUncheckedUpdateWithoutProductInput>
    create: XOR<ProductSEOCreateWithoutProductInput, ProductSEOUncheckedCreateWithoutProductInput>
    where?: ProductSEOWhereInput
  }

  export type ProductSEOUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductSEOWhereInput
    data: XOR<ProductSEOUpdateWithoutProductInput, ProductSEOUncheckedUpdateWithoutProductInput>
  }

  export type ProductSEOUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSEOUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    shopifyId?: StringFilter<"ProductVariant"> | string
    title?: StringNullableFilter<"ProductVariant"> | string | null
    productId?: StringNullableFilter<"ProductVariant"> | string | null
    productVariantProductId?: StringNullableFilter<"ProductVariant"> | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductFeaturedMediaUpsertWithoutProductInput = {
    update: XOR<ProductFeaturedMediaUpdateWithoutProductInput, ProductFeaturedMediaUncheckedUpdateWithoutProductInput>
    create: XOR<ProductFeaturedMediaCreateWithoutProductInput, ProductFeaturedMediaUncheckedCreateWithoutProductInput>
    where?: ProductFeaturedMediaWhereInput
  }

  export type ProductFeaturedMediaUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductFeaturedMediaWhereInput
    data: XOR<ProductFeaturedMediaUpdateWithoutProductInput, ProductFeaturedMediaUncheckedUpdateWithoutProductInput>
  }

  export type ProductFeaturedMediaUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type ProductFeaturedMediaUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    mediaContentType?: EnumMediaContentTypeFieldUpdateOperationsInput | $Enums.MediaContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredMediaVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaExternalVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaImageId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredMediaVideo?: FeaturedMediaVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaExternalVideo?: FeaturedMediaExternalVideoUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
    featuredMediaImage?: FeaturedMediaImageUncheckedUpdateOneWithoutProductFeaturedMediaNestedInput
  }

  export type OrderCreateWithoutOrderPriceInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    Shop?: ShopCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutOrderPriceInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    shopId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderPriceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderPriceInput, OrderUncheckedCreateWithoutOrderPriceInput>
  }

  export type OrderUpsertWithoutOrderPriceInput = {
    update: XOR<OrderUpdateWithoutOrderPriceInput, OrderUncheckedUpdateWithoutOrderPriceInput>
    create: XOR<OrderCreateWithoutOrderPriceInput, OrderUncheckedCreateWithoutOrderPriceInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderPriceInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderPriceInput, OrderUncheckedUpdateWithoutOrderPriceInput>
  }

  export type OrderUpdateWithoutOrderPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    Shop?: ShopUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPriceCreateWithoutOrderInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    currencyCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderPriceUncheckedCreateWithoutOrderInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    currencyCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderPriceCreateOrConnectWithoutOrderInput = {
    where: OrderPriceWhereUniqueInput
    create: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
  }

  export type ShopCreateWithoutOrdersInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutShopInput
    collections?: CollectionCreateNestedManyWithoutShopInput
    User?: UserCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutOrdersInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    collections?: CollectionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOrdersInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
  }

  export type OrderPriceUpsertWithoutOrderInput = {
    update: XOR<OrderPriceUpdateWithoutOrderInput, OrderPriceUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderPriceCreateWithoutOrderInput, OrderPriceUncheckedCreateWithoutOrderInput>
    where?: OrderPriceWhereInput
  }

  export type OrderPriceUpdateToOneWithWhereWithoutOrderInput = {
    where?: OrderPriceWhereInput
    data: XOR<OrderPriceUpdateWithoutOrderInput, OrderPriceUncheckedUpdateWithoutOrderInput>
  }

  export type OrderPriceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPriceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUpsertWithoutOrdersInput = {
    update: XOR<ShopUpdateWithoutOrdersInput, ShopUncheckedUpdateWithoutOrdersInput>
    create: XOR<ShopCreateWithoutOrdersInput, ShopUncheckedCreateWithoutOrdersInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutOrdersInput, ShopUncheckedUpdateWithoutOrdersInput>
  }

  export type ShopUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutShopNestedInput
    collections?: CollectionUpdateManyWithoutShopNestedInput
    User?: UserUpdateOneWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutShopNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type CollectionCreateWithoutCollectionImageInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Shop?: ShopCreateNestedOneWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateWithoutCollectionImageInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shopId?: string | null
  }

  export type CollectionCreateOrConnectWithoutCollectionImageInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutCollectionImageInput, CollectionUncheckedCreateWithoutCollectionImageInput>
  }

  export type CollectionUpsertWithoutCollectionImageInput = {
    update: XOR<CollectionUpdateWithoutCollectionImageInput, CollectionUncheckedUpdateWithoutCollectionImageInput>
    create: XOR<CollectionCreateWithoutCollectionImageInput, CollectionUncheckedCreateWithoutCollectionImageInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutCollectionImageInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutCollectionImageInput, CollectionUncheckedUpdateWithoutCollectionImageInput>
  }

  export type CollectionUpdateWithoutCollectionImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shop?: ShopUpdateOneWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateWithoutCollectionImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionImageCreateWithoutCollectionInput = {
    id?: string
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionImageUncheckedCreateWithoutCollectionInput = {
    id?: string
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionImageCreateOrConnectWithoutCollectionInput = {
    where: CollectionImageWhereUniqueInput
    create: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
  }

  export type ShopCreateWithoutCollectionsInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutShopInput
    orders?: OrderCreateNestedManyWithoutShopInput
    User?: UserCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutCollectionsInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    orders?: OrderUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutCollectionsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutCollectionsInput, ShopUncheckedCreateWithoutCollectionsInput>
  }

  export type CollectionImageUpsertWithoutCollectionInput = {
    update: XOR<CollectionImageUpdateWithoutCollectionInput, CollectionImageUncheckedUpdateWithoutCollectionInput>
    create: XOR<CollectionImageCreateWithoutCollectionInput, CollectionImageUncheckedCreateWithoutCollectionInput>
    where?: CollectionImageWhereInput
  }

  export type CollectionImageUpdateToOneWithWhereWithoutCollectionInput = {
    where?: CollectionImageWhereInput
    data: XOR<CollectionImageUpdateWithoutCollectionInput, CollectionImageUncheckedUpdateWithoutCollectionInput>
  }

  export type CollectionImageUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionImageUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUpsertWithoutCollectionsInput = {
    update: XOR<ShopUpdateWithoutCollectionsInput, ShopUncheckedUpdateWithoutCollectionsInput>
    create: XOR<ShopCreateWithoutCollectionsInput, ShopUncheckedCreateWithoutCollectionsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutCollectionsInput, ShopUncheckedUpdateWithoutCollectionsInput>
  }

  export type ShopUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutShopNestedInput
    orders?: OrderUpdateManyWithoutShopNestedInput
    User?: UserUpdateOneWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutShopNestedInput
    orders?: OrderUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ProductCreateWithoutShopInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    ProductSEO?: ProductSEOCreateNestedOneWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutShopInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
    ProductSEO?: ProductSEOUncheckedCreateNestedOneWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
    featuredMedia?: ProductFeaturedMediaUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutShopInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput>
  }

  export type ProductCreateManyShopInputEnvelope = {
    data: ProductCreateManyShopInput | ProductCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutShopInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    orderPrice?: OrderPriceCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutShopInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
    orderPrice?: OrderPriceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutShopInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput>
  }

  export type OrderCreateManyShopInputEnvelope = {
    data: OrderCreateManyShopInput | OrderCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCreateWithoutShopInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionImage?: CollectionImageCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutShopInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionImage?: CollectionImageUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutShopInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput>
  }

  export type CollectionCreateManyShopInputEnvelope = {
    data: CollectionCreateManyShopInput | CollectionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutShopsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShopsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShopsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutShopInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutShopInput, ProductUncheckedUpdateWithoutShopInput>
    create: XOR<ProductCreateWithoutShopInput, ProductUncheckedCreateWithoutShopInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutShopInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutShopInput, ProductUncheckedUpdateWithoutShopInput>
  }

  export type ProductUpdateManyWithWhereWithoutShopInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutShopInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    shopifyId?: StringFilter<"Product"> | string
    handle?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    title?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    onlineStoreUrl?: StringFilter<"Product"> | string
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    productSEOId?: StringNullableFilter<"Product"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutShopInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutShopInput, OrderUncheckedUpdateWithoutShopInput>
    create: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutShopInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutShopInput, OrderUncheckedUpdateWithoutShopInput>
  }

  export type OrderUpdateManyWithWhereWithoutShopInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutShopInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringFilter<"Order"> | string
    shopifyId?: StringFilter<"Order"> | string
    unpaid?: BoolFilter<"Order"> | boolean
    processedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderPriceId?: StringNullableFilter<"Order"> | string | null
    shopId?: StringNullableFilter<"Order"> | string | null
  }

  export type CollectionUpsertWithWhereUniqueWithoutShopInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutShopInput, CollectionUncheckedUpdateWithoutShopInput>
    create: XOR<CollectionCreateWithoutShopInput, CollectionUncheckedCreateWithoutShopInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutShopInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutShopInput, CollectionUncheckedUpdateWithoutShopInput>
  }

  export type CollectionUpdateManyWithWhereWithoutShopInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutShopInput>
  }

  export type CollectionScalarWhereInput = {
    AND?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    OR?: CollectionScalarWhereInput[]
    NOT?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    id?: StringFilter<"Collection"> | string
    shopifyId?: StringFilter<"Collection"> | string
    title?: StringNullableFilter<"Collection"> | string | null
    description?: StringNullableFilter<"Collection"> | string | null
    handle?: StringFilter<"Collection"> | string
    collectionImageId?: StringNullableFilter<"Collection"> | string | null
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
    shopId?: StringNullableFilter<"Collection"> | string | null
  }

  export type UserUpsertWithoutShopsInput = {
    update: XOR<UserUpdateWithoutShopsInput, UserUncheckedUpdateWithoutShopsInput>
    create: XOR<UserCreateWithoutShopsInput, UserUncheckedCreateWithoutShopsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShopsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShopsInput, UserUncheckedUpdateWithoutShopsInput>
  }

  export type UserUpdateWithoutShopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutUserInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutShopInput
    orders?: OrderCreateNestedManyWithoutShopInput
    collections?: CollectionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutUserInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutShopInput
    orders?: OrderUncheckedCreateNestedManyWithoutShopInput
    collections?: CollectionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutUserInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput>
  }

  export type ShopCreateManyUserInputEnvelope = {
    data: ShopCreateManyUserInput | ShopCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ShopUpsertWithWhereUniqueWithoutUserInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutUserInput, ShopUncheckedUpdateWithoutUserInput>
    create: XOR<ShopCreateWithoutUserInput, ShopUncheckedCreateWithoutUserInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutUserInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutUserInput, ShopUncheckedUpdateWithoutUserInput>
  }

  export type ShopUpdateManyWithWhereWithoutUserInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutUserInput>
  }

  export type ShopScalarWhereInput = {
    AND?: ShopScalarWhereInput | ShopScalarWhereInput[]
    OR?: ShopScalarWhereInput[]
    NOT?: ShopScalarWhereInput | ShopScalarWhereInput[]
    id?: StringFilter<"Shop"> | string
    shopifyId?: StringFilter<"Shop"> | string
    myshopifyDomain?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    description?: StringNullableFilter<"Shop"> | string | null
    shipsToCountries?: StringNullableListFilter<"Shop">
    accessToken?: StringFilter<"Shop"> | string
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    userId?: StringNullableFilter<"Shop"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    shops?: ShopCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    shops?: ShopCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    shops?: ShopUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    shops?: ShopUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    shops?: ShopUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    shopifyId: string
    title?: string | null
    productVariantProductId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariantProduct?: ProductVariantProductUpdateOneWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productVariantProduct?: ProductVariantProductUncheckedUpdateOneWithoutProductVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    productVariantProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyShopInput = {
    id?: string
    shopifyId: string
    handle: string
    description?: string | null
    title?: string | null
    tags?: ProductCreatetagsInput | string[]
    onlineStoreUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSEOId?: string | null
  }

  export type OrderCreateManyShopInput = {
    id?: string
    name: string
    shopifyId: string
    unpaid?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderPriceId?: string | null
  }

  export type CollectionCreateManyShopInput = {
    id?: string
    shopifyId: string
    title?: string | null
    description?: string | null
    handle: string
    collectionImageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductSEO?: ProductSEOUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductSEO?: ProductSEOUncheckedUpdateOneWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
    featuredMedia?: ProductFeaturedMediaUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    onlineStoreUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSEOId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPrice?: OrderPriceUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPrice?: OrderPriceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    unpaid?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderPriceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionImage?: CollectionImageUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionImage?: CollectionImageUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: StringFieldUpdateOperationsInput | string
    collectionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ShopCreateManyUserInput = {
    id?: string
    shopifyId: string
    myshopifyDomain: string
    name: string
    description?: string | null
    shipsToCountries?: ShopCreateshipsToCountriesInput | string[]
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutShopNestedInput
    orders?: OrderUpdateManyWithoutShopNestedInput
    collections?: CollectionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutShopNestedInput
    orders?: OrderUncheckedUpdateManyWithoutShopNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyId?: StringFieldUpdateOperationsInput | string
    myshopifyDomain?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shipsToCountries?: ShopUpdateshipsToCountriesInput | string[]
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}